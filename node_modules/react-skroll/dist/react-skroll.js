(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"), require("ReactDOM"));
	else if(typeof define === 'function' && define.amd)
		define(["React", "ReactDOM"], factory);
	else if(typeof exports === 'object')
		exports["ReactSkroll"] = factory(require("React"), require("ReactDOM"));
	else
		root["ReactSkroll"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_29__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.utilities = exports.scrollConnect = exports.ScrollProvider = exports.ScrollLink = exports.Scroller = undefined;

	var _Scroller2 = __webpack_require__(16);

	var _Scroller3 = _interopRequireDefault(_Scroller2);

	var _ScrollLink2 = __webpack_require__(14);

	var _ScrollLink3 = _interopRequireDefault(_ScrollLink2);

	var _ScrollProvider2 = __webpack_require__(15);

	var _ScrollProvider3 = _interopRequireDefault(_ScrollProvider2);

	var _scrollConnect2 = __webpack_require__(19);

	var _scrollConnect3 = _interopRequireDefault(_scrollConnect2);

	var _utilities2 = __webpack_require__(2);

	var _utilities = _interopRequireWildcard(_utilities2);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Scroller = _Scroller3.default;
	exports.ScrollLink = _ScrollLink3.default;
	exports.ScrollProvider = _ScrollProvider3.default;
	exports.scrollConnect = _scrollConnect3.default;
	exports.utilities = _utilities;
	exports.default = exports;

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.contextProviderShape = exports.nodeChildrenToScrollState = exports.nodeToScrollState = undefined;

	var _nodeToScrollState2 = __webpack_require__(18);

	var _nodeToScrollState3 = _interopRequireDefault(_nodeToScrollState2);

	var _nodeChildrenToScrollState2 = __webpack_require__(17);

	var _nodeChildrenToScrollState3 = _interopRequireDefault(_nodeChildrenToScrollState2);

	var _contextProviderShape2 = __webpack_require__(4);

	var _contextProviderShape3 = _interopRequireDefault(_contextProviderShape2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.nodeToScrollState = _nodeToScrollState3.default;
	exports.nodeChildrenToScrollState = _nodeChildrenToScrollState3.default;
	exports.contextProviderShape = _contextProviderShape3.default;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1
	(function() {
	  var getNanoSeconds, hrtime, loadTime;

	  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
	    module.exports = function() {
	      return performance.now();
	    };
	  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
	    module.exports = function() {
	      return (getNanoSeconds() - loadTime) / 1e6;
	    };
	    hrtime = process.hrtime;
	    getNanoSeconds = function() {
	      var hr;
	      hr = hrtime();
	      return hr[0] * 1e9 + hr[1];
	    };
	    loadTime = getNanoSeconds();
	  } else if (Date.now) {
	    module.exports = function() {
	      return Date.now() - loadTime;
	    };
	    loadTime = Date.now();
	  } else {
	    module.exports = function() {
	      return new Date().getTime() - loadTime;
	    };
	    loadTime = new Date().getTime();
	  }

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20)))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(1);

	exports.default = _react.PropTypes.shape({
	  position: _react.PropTypes.number,
	  positionRatio: _react.PropTypes.number,
	  start: _react.PropTypes.number,
	  end: _react.PropTypes.number,
	  viewHeight: _react.PropTypes.number,
	  scrollHeight: _react.PropTypes.number,
	  ready: _react.PropTypes.bool,
	  onStart: _react.PropTypes.bool,
	  onMiddle: _react.PropTypes.bool,
	  onEnd: _react.PropTypes.bool,
	  children: _react.PropTypes.arrayOf(_react.PropTypes.object),

	  autoFrame: _react.PropTypes.bool,
	  autoScroll: _react.PropTypes.bool,

	  originalPosition: _react.PropTypes.number,
	  changedPosition: _react.PropTypes.number,
	  timeStamp: _react.PropTypes.number,
	  scrolling: _react.PropTypes.bool,
	  wheeling: _react.PropTypes.bool,
	  touching: _react.PropTypes.bool,
	  moving: _react.PropTypes.bool,
	  resting: _react.PropTypes.bool,
	  // touches: PropTypes.object,

	  node: _react.PropTypes.object,

	  setNode: _react.PropTypes.func,
	  unsetNode: _react.PropTypes.func,
	  handleScroll: _react.PropTypes.func,
	  handleWheel: _react.PropTypes.func,
	  handleTouchStart: _react.PropTypes.func,
	  handleTouchMove: _react.PropTypes.func,
	  handleTouchEnd: _react.PropTypes.func,
	  scrollTo: _react.PropTypes.func,
	  scrollToPosition: _react.PropTypes.func,
	  scrollToByIndex: _react.PropTypes.func,
	  scrollToTop: _react.PropTypes.func,
	  scrollToBottom: _react.PropTypes.func,
	  scrollToName: _react.PropTypes.func,
	  scrollToElement: _react.PropTypes.func,
	  setStateMove: _react.PropTypes.func,
	  setStateRest: _react.PropTypes.func,
	  setStateStart: _react.PropTypes.func,
	  setStateEnd: _react.PropTypes.func
	});

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__(3)
	  , root = typeof window === 'undefined' ? global : window
	  , vendors = ['moz', 'webkit']
	  , suffix = 'AnimationFrame'
	  , raf = root['request' + suffix]
	  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

	for(var i = 0; !raf && i < vendors.length; i++) {
	  raf = root[vendors[i] + 'Request' + suffix]
	  caf = root[vendors[i] + 'Cancel' + suffix]
	      || root[vendors[i] + 'CancelRequest' + suffix]
	}

	// Some versions of FF have rAF but not cAF
	if(!raf || !caf) {
	  var last = 0
	    , id = 0
	    , queue = []
	    , frameDuration = 1000 / 60

	  raf = function(callback) {
	    if(queue.length === 0) {
	      var _now = now()
	        , next = Math.max(0, frameDuration - (_now - last))
	      last = next + _now
	      setTimeout(function() {
	        var cp = queue.slice(0)
	        // Clear queue here to prevent
	        // callbacks from appending listeners
	        // to the current frame's queue
	        queue.length = 0
	        for(var i = 0; i < cp.length; i++) {
	          if(!cp[i].cancelled) {
	            try{
	              cp[i].callback(last)
	            } catch(e) {
	              setTimeout(function() { throw e }, 0)
	            }
	          }
	        }
	      }, Math.round(next))
	    }
	    queue.push({
	      handle: ++id,
	      callback: callback,
	      cancelled: false
	    })
	    return id
	  }

	  caf = function(handle) {
	    for(var i = 0; i < queue.length; i++) {
	      if(queue[i].handle === handle) {
	        queue[i].cancelled = true
	      }
	    }
	  }
	}

	module.exports = function(fn) {
	  // Wrap in a new function to prevent
	  // `cancel` potentially being assigned
	  // to the native rAF function
	  return raf.call(root, fn)
	}
	module.exports.cancel = function() {
	  caf.apply(root, arguments)
	}
	module.exports.polyfill = function() {
	  root.requestAnimationFrame = raf
	  root.cancelAnimationFrame = caf
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports) {

	

	// currently used to initiate the velocity style object to 0
	'use strict';

	exports.__esModule = true;
	exports['default'] = mapToZero;

	function mapToZero(obj) {
	  var ret = {};
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) {
	      ret[key] = 0;
	    }
	  }
	  return ret;
	}

	module.exports = exports['default'];

/***/ },
/* 7 */
/***/ function(module, exports) {

	

	// usage assumption: currentStyle values have already been rendered but it says
	// nothing of whether currentStyle is stale (see unreadPropStyle)
	'use strict';

	exports.__esModule = true;
	exports['default'] = shouldStopAnimation;

	function shouldStopAnimation(currentStyle, style, currentVelocity) {
	  for (var key in style) {
	    if (!Object.prototype.hasOwnProperty.call(style, key)) {
	      continue;
	    }

	    if (currentVelocity[key] !== 0) {
	      return false;
	    }

	    var styleValue = typeof style[key] === 'number' ? style[key] : style[key].val;
	    // stepper will have already taken care of rounding precision errors, so
	    // won't have such thing as 0.9999 !=== 1
	    if (currentStyle[key] !== styleValue) {
	      return false;
	    }
	  }

	  return true;
	}

	module.exports = exports['default'];

/***/ },
/* 8 */
/***/ function(module, exports) {

	

	// stepper is used a lot. Saves allocation to return the same array wrapper.
	// This is fine and danger-free against mutations because the callsite
	// immediately destructures it and gets the numbers inside without passing the
	"use strict";

	exports.__esModule = true;
	exports["default"] = stepper;

	var reusedTuple = [0, 0];

	function stepper(secondPerFrame, x, v, destX, k, b, precision) {
	  // Spring stiffness, in kg / s^2

	  // for animations, destX is really spring length (spring at rest). initial
	  // position is considered as the stretched/compressed position of a spring
	  var Fspring = -k * (x - destX);

	  // Damping, in kg / s
	  var Fdamper = -b * v;

	  // usually we put mass here, but for animation purposes, specifying mass is a
	  // bit redundant. you could simply adjust k and b accordingly
	  // let a = (Fspring + Fdamper) / mass;
	  var a = Fspring + Fdamper;

	  var newV = v + a * secondPerFrame;
	  var newX = x + newV * secondPerFrame;

	  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {
	    reusedTuple[0] = destX;
	    reusedTuple[1] = 0;
	    return reusedTuple;
	  }

	  reusedTuple[0] = newX;
	  reusedTuple[1] = newV;
	  return reusedTuple;
	}

	module.exports = exports["default"];
	// array reference around.

/***/ },
/* 9 */
/***/ function(module, exports) {

	
	// turn {x: {val: 1, stiffness: 1, damping: 2}, y: 2} generated by
	// `{x: spring(1, {stiffness: 1, damping: 2}), y: 2}` into {x: 1, y: 2}

	'use strict';

	exports.__esModule = true;
	exports['default'] = stripStyle;

	function stripStyle(style) {
	  var ret = {};
	  for (var key in style) {
	    if (!Object.prototype.hasOwnProperty.call(style, key)) {
	      continue;
	    }
	    ret[key] = typeof style[key] === 'number' ? style[key] : style[key].val;
	  }
	  return ret;
	}

	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = {
	  noWobble: { stiffness: 170, damping: 26 }, // the default, if nothing provided
	  gentle: { stiffness: 120, damping: 14 },
	  wobbly: { stiffness: 180, damping: 12 },
	  stiff: { stiffness: 210, damping: 20 }
	};
	module.exports = exports["default"];

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _Motion = __webpack_require__(21);

	exports.Motion = _interopRequire(_Motion);

	var _StaggeredMotion = __webpack_require__(22);

	exports.StaggeredMotion = _interopRequire(_StaggeredMotion);

	var _TransitionMotion = __webpack_require__(23);

	exports.TransitionMotion = _interopRequire(_TransitionMotion);

	var _spring = __webpack_require__(26);

	exports.spring = _interopRequire(_spring);

	var _presets = __webpack_require__(10);

	exports.presets = _interopRequire(_presets);

	// deprecated, dummy warning function

	var _reorderKeys = __webpack_require__(25);

	exports.reorderKeys = _interopRequire(_reorderKeys);

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ResizeObserver = factory());
	}(this, (function () {
	'use strict';

	/**
	 * Exports global object for the current environment.
	 */
	var global$1 = (function () {
	    if (typeof self != 'undefined' && self.Math === Math) {
	        return self;
	    }

	    if (typeof window != 'undefined' && window.Math === Math) {
	        return window;
	    }

	    if (typeof global != 'undefined' && global.Math === Math) {
	        return global;
	    }

	    // eslint-disable-next-line no-new-func
	    return Function('return this')();
	})();

	var classCallCheck = function (instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	};

	var createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];
	            descriptor.enumerable = descriptor.enumerable || false;
	            descriptor.configurable = true;
	            if ("value" in descriptor) descriptor.writable = true;
	            Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }

	    return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);
	        if (staticProps) defineProperties(Constructor, staticProps);
	        return Constructor;
	    };
	}();

	var inherits = function (subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	        constructor: {
	            value: subClass,
	            enumerable: false,
	            writable: true,
	            configurable: true
	        }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	/**
	 * A collection of shims that provides minimal
	 * support of WeakMap and Map classes.
	 *
	 * These implementations are not meant to be used outside of
	 * ResizeObserver modules as they cover only a limited range
	 * of use cases.
	 */
	/* eslint-disable require-jsdoc */
	var hasNativeCollections = typeof global$1.WeakMap === 'function' && typeof global$1.Map === 'function';

	var WeakMap = function () {
	    if (hasNativeCollections) {
	        return global$1.WeakMap;
	    }

	    function getIndex(arr, key) {
	        var result = -1;

	        arr.some(function (entry, index) {
	            var matches = entry[0] === key;

	            if (matches) {
	                result = index;
	            }

	            return matches;
	        });

	        return result;
	    }

	    return function () {
	        function _class() {
	            classCallCheck(this, _class);

	            this.__entries__ = [];
	        }

	        _class.prototype.get = function get(key) {
	            var index = getIndex(this.__entries__, key);

	            return this.__entries__[index][1];
	        };

	        _class.prototype.set = function set(key, value) {
	            var index = getIndex(this.__entries__, key);

	            if (~index) {
	                this.__entries__[index][1] = value;
	            } else {
	                this.__entries__.push([key, value]);
	            }
	        };

	        _class.prototype.delete = function _delete(key) {
	            var entries = this.__entries__,
	                index = getIndex(entries, key);

	            if (~index) {
	                entries.splice(index, 1);
	            }
	        };

	        _class.prototype.has = function has(key) {
	            return !!~getIndex(this.__entries__, key);
	        };

	        return _class;
	    }();
	}();

	var Map = function () {
	    if (hasNativeCollections) {
	        return global$1.Map;
	    }

	    return function (_WeakMap) {
	        inherits(_class2, _WeakMap);

	        function _class2() {
	            classCallCheck(this, _class2);
	            return possibleConstructorReturn(this, _WeakMap.apply(this, arguments));
	        }

	        _class2.prototype.clear = function clear() {
	            this.__entries__.splice(0, this.__entries__.length);
	        };

	        _class2.prototype.entries = function entries() {
	            return this.__entries__.slice();
	        };

	        _class2.prototype.keys = function keys() {
	            return this.__entries__.map(function (entry) {
	                return entry[0];
	            });
	        };

	        _class2.prototype.values = function values() {
	            return this.__entries__.map(function (entry) {
	                return entry[1];
	            });
	        };

	        _class2.prototype.forEach = function forEach(callback) {
	            var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	            for (var _iterator = this.__entries__, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	                var _ref;

	                if (_isArray) {
	                    if (_i >= _iterator.length) break;
	                    _ref = _iterator[_i++];
	                } else {
	                    _i = _iterator.next();
	                    if (_i.done) break;
	                    _ref = _i.value;
	                }

	                var entry = _ref;

	                callback.call(ctx, entry[1], entry[0]);
	            }
	        };

	        createClass(_class2, [{
	            key: 'size',
	            get: function get() {
	                return this.__entries__.length;
	            }
	        }]);
	        return _class2;
	    }(WeakMap);
	}();

	/**
	 * Detects whether window and document objects are available in current environment.
	 */
	var isBrowser = global$1.window === global$1 && typeof document != 'undefined';

	// Placeholder of an empty content rectangle.
	var emptyRect = createContentRect(0, 0, 0, 0);

	/**
	 * Extracts computed styles of provided element.
	 *
	 * @param {Element} target
	 * @returns {CSSStyleDeclaration}
	 */
	function getStyles(target) {
	    return getComputedStyle(target);
	}

	/**
	 * Converts provided string defined in q form of '{{value}}px' to number.
	 *
	 * @param {String} value
	 * @returns {Number}
	 */
	function pixelsToNumber(value) {
	    return parseFloat(value) || 0;
	}

	/**
	 * Extracts borders size from provided styles.
	 *
	 * @param {CSSStyleDeclaration} styles
	 * @param {...String} positions - Borders positions (top, right, ...)
	 * @returns {Number}
	 */
	function getBordersSize(styles) {
	    for (var _len = arguments.length, positions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        positions[_key - 1] = arguments[_key];
	    }

	    return positions.reduce(function (size, pos) {
	        var value = styles['border-' + pos + '-width'];

	        return size + pixelsToNumber(value);
	    }, 0);
	}

	/**
	 * Extracts paddings sizes from provided styles.
	 *
	 * @param {CSSStyleDeclaration} styles
	 * @returns {Object} Paddings box.
	 */
	function getPaddings(styles) {
	    var boxKeys = ['top', 'right', 'bottom', 'left'];
	    var paddings = {};

	    for (var _iterator = boxKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;

	        if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	        } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	        }

	        var key = _ref;

	        var value = styles['padding-' + key];

	        paddings[key] = pixelsToNumber(value);
	    }

	    return paddings;
	}

	/**
	 * Creates content rectangle based on the provided dimensions
	 * and the top/left positions.
	 *
	 * @param {Number} width - Width of rectangle.
	 * @param {Number} height - Height of rectangle.
	 * @param {Number} top - Top position.
	 * @param {Number} left - Left position.
	 * @returns {ClientRect}
	 */
	function createContentRect(width, height, top, left) {
	    return {
	        width: width, height: height, top: top,
	        right: width + left,
	        bottom: height + top,
	        left: left
	    };
	}

	/**
	 * Calculates content rectangle of provided SVG element.
	 *
	 * @param {SVGElement} target - Element whose content
	 *      rectangle needs to be calculated.
	 * @returns {ClientRect}
	 */
	function getSVGContentRect(target) {
	    var bbox = target.getBBox();

	    return createContentRect(bbox.width, bbox.height, 0, 0);
	}

	/**
	 * Calculates content rectangle of a root element.
	 *
	 * @returns {ClientRect}
	 */
	function getDocElementRect() {
	    // Neither scroll[Width/Height] nor offset[Width/Height] can be used to
	    // define content dimensions as they give inconsistent results across
	    // different browsers. E.g. in the Internet Explorer 10 and lower value of
	    // these properties can't be less than the client dimensions (same thing
	    // with the "getBoundingClientRect" method). And Firefox has the same
	    // behavior with its "scroll" properties.
	    var styles = getStyles(document.documentElement);

	    var width = pixelsToNumber(styles.width);
	    var height = pixelsToNumber(styles.height);

	    return createContentRect(width, height, 0, 0);
	}

	/**
	 * Calculates content rectangle of provided HTMLElement.
	 *
	 * @param {HTMLElement} target - Element whose content
	 *      rectangle needs to be calculated.
	 * @returns {ClientRect}
	 */
	function getHTMLElementContentRect(target) {
	    // Client width & height properties can't be
	    // used exclusively as they provide rounded values.
	    var clientWidth = target.clientWidth,
	        clientHeight = target.clientHeight;

	    // By this condition we can catch all non-replaced inline, hidden and detached
	    // elements. Though elements with width & height properties less than 0.5 will
	    // be discarded as well.
	    //
	    // Without it we would need to implement separate methods for each of
	    // those cases and it's not possible to perform a precise and performance
	    // effective test for hidden elements. E.g. even jQuerys' ':visible' filter
	    // gives wrong results for elements with width & height less than 0.5.

	    if (!clientWidth && !clientHeight) {
	        return emptyRect;
	    }

	    var styles = getStyles(target);
	    var paddings = getPaddings(styles);
	    var horizPad = paddings.left + paddings.right;
	    var vertPad = paddings.top + paddings.bottom;

	    // Computed styles of width & height are being used because they are the
	    // only dimensions available to JS that contain non-rounded values. It could
	    // be possible to utilize getBoundingClientRect if only its' data wasn't
	    // affected by CSS transformations let alone paddings, borders and scroll bars.
	    var width = pixelsToNumber(styles.width),
	        height = pixelsToNumber(styles.height);

	    // Width & height include paddings and borders
	    // when 'border-box' box model is applied (except for IE).
	    if (styles.boxSizing === 'border-box') {
	        // Following conditions are required to handle Internet Explorer which
	        // doesn't include paddings and borders to computed CSS dimensions.
	        //
	        // We can say that if CSS dimensions + paddings are equal to the "client"
	        // properties then it's either IE, and thus we don't need to subtract
	        // anything, or an element merely doesn't have paddings/borders styles.
	        if (Math.round(width + horizPad) !== clientWidth) {
	            width -= getBordersSize(styles, 'left', 'right') + horizPad;
	        }

	        if (Math.round(height + vertPad) !== clientHeight) {
	            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
	        }
	    }

	    // In some browsers (only in Firefox, actually) CSS width & height
	    // include scroll bars size which can be removed at this step as scroll bars
	    // are the only difference between rounded dimensions + paddings and "client"
	    // properties, though that is not always true in Chrome.
	    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
	    var horizScrollbar = Math.round(height + vertPad) - clientHeight;

	    // Chrome has a rather weird rounding of "client" properties.
	    // E.g. for an element with content width of 314.2px it sometimes gives the
	    // client width of 315px and for the width of 314.7px it may give 314px.
	    // And it doesn't happen all the time. Such difference needs to be ignored.
	    if (Math.abs(vertScrollbar) !== 1) {
	        width -= vertScrollbar;
	    }

	    if (Math.abs(horizScrollbar) !== 1) {
	        height -= horizScrollbar;
	    }

	    return createContentRect(width, height, paddings.top, paddings.left);
	}

	/**
	 * Checks whether provided element is an instance of SVGElement.
	 *
	 * @param {Element} target - Element to be checked.
	 * @returns {Boolean}
	 */
	function isSVGElement(target) {
	    return target instanceof SVGElement;
	}

	/**
	 * Checks whether provided element is a document element (root element of a document).
	 *
	 * @param {Element} target - Element to be checked.
	 * @returns {Boolean}
	 */
	function isDocumentElement(target) {
	    return target === document.documentElement;
	}

	/**
	 * Calculates an appropriate content rectangle for provided html or svg element.
	 *
	 * @param {Element} target - Element whose content rectangle
	 *      needs to be calculated.
	 * @returns {ClientRect}
	 */
	function getContentRect(target) {
	    // Return empty rectangle if running in a non-browser environment.
	    if (!isBrowser) {
	        return emptyRect;
	    }

	    if (isSVGElement(target)) {
	        return getSVGContentRect(target);
	    }

	    if (isDocumentElement(target)) {
	        return getDocElementRect();
	    }

	    return getHTMLElementContentRect(target);
	}

	/**
	 * Class that is responsible for computations of the content rectangle of
	 * provided DOM element and for keeping track of its' changes.
	 */
	var ResizeObservation = function () {
	    /**
	     * Creates an instance of ResizeObservation.
	     *
	     * @param {Element} target - Element to be observed.
	     */
	    function ResizeObservation(target) {
	        classCallCheck(this, ResizeObservation);

	        this.target = target;

	        // Keeps reference to the last observed content rectangle.
	        this._contentRect = emptyRect;

	        // Broadcasted width of content rectangle.
	        this.broadcastWidth = 0;

	        // Broadcasted height of content rectangle.
	        this.broadcastHeight = 0;
	    }

	    /**
	     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
	     * from the corresponding properties of the last observed content rectangle.
	     *
	     * @returns {ClientRect} Last observed content rectangle.
	     */
	    ResizeObservation.prototype.broadcastRect = function broadcastRect() {
	        var rect = this._contentRect;

	        this.broadcastWidth = rect.width;
	        this.broadcastHeight = rect.height;

	        return rect;
	    };

	    /**
	     * Updates content rectangle and tells whether its' width or height properties
	     * have changed since the last broadcast.
	     *
	     * @returns {Boolean}
	     */
	    ResizeObservation.prototype.isActive = function isActive() {
	        var rect = getContentRect(this.target);

	        this._contentRect = rect;

	        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
	    };

	    return ResizeObservation;
	}();

	/**
	 * Defines properties of the provided target object.
	 *
	 * @param {Object} target - Object for which to define properties.
	 * @param {Object} props - Properties to be defined.
	 * @param {Object} [descr = {}] - Properties descriptor.
	 * @returns {Object} Target object.
	 */
	function defineProperties(target, props) {
	    var descr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    var descriptor = {
	        configurable: descr.configurable || false,
	        writable: descr.writable || false,
	        enumerable: descr.enumerable || false
	    };

	    for (var _iterator = Object.keys(props), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;

	        if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	        } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	        }

	        var key = _ref;

	        descriptor.value = props[key];

	        Object.defineProperty(target, key, descriptor);
	    }

	    return target;
	}

	var ResizeObserverEntry =
	/**
	 * Creates an instance of ResizeObserverEntry.
	 *
	 * @param {Element} target - Element that is being observed.
	 * @param {ClientRect} rectData - Data of the elements' content rectangle.
	 */
	function ResizeObserverEntry(target, rectData) {
	    classCallCheck(this, ResizeObserverEntry);

	    // Content rectangle needs to be an instance of ClientRect if it's
	    // available.
	    var rectInterface = global$1.ClientRect || Object;
	    var contentRect = Object.create(rectInterface.prototype);

	    // According to the specification following properties are not writable
	    // and are also not enumerable in the native implementation.
	    //
	    // Property accessors are not being used as they'd require to define a
	    // private WeakMap storage which may cause memory leaks in browsers that
	    // don't support this type of collections.
	    defineProperties(contentRect, rectData, { configurable: true });

	    defineProperties(this, {
	        target: target, contentRect: contentRect
	    }, { configurable: true });
	};

	var ResizeObserver$2 = function () {
	    /**
	     * Creates a new instance of ResizeObserver.
	     *
	     * @param {Function} callback - Callback function that is invoked when one
	     *      of the observed elements changes it's content rectangle.
	     * @param {ResizeObsreverController} controller - Controller instance which
	     *      is responsible for the updates of observer.
	     * @param {ResizeObserver} publicObserver - Reference to the public
	     *      ResizeObserver instance which will be passed to callback function.
	     */
	    function ResizeObserver(callback, controller, publicObserver) {
	        classCallCheck(this, ResizeObserver);

	        if (typeof callback !== 'function') {
	            throw new TypeError('The callback provided as parameter 1 is not a function.');
	        }

	        // Reference to the callback function.
	        this._callback = callback;

	        // Registry of ResizeObservation instances.
	        this._targets = new Map();

	        // Collection of resize observations that have detected changes in
	        // dimensions of elements.
	        this._activeTargets = [];

	        // Reference to the associated ResizeObserverController.
	        this._controller = controller;

	        // Public ResizeObserver instance which will be passed to callback function.
	        this._publicObserver = publicObserver;
	    }

	    /**
	     * Starts observing provided element.
	     *
	     * @param {Element} target - Element to be observed.
	     */
	    ResizeObserver.prototype.observe = function observe(target) {
	        if (!arguments.length) {
	            throw new TypeError('1 argument required, but only 0 present.');
	        }

	        // Do nothing if current environment doesn't have the Element interface.
	        if (!('Element' in global$1) || !(Element instanceof Object)) {
	            return;
	        }

	        if (!(target instanceof Element)) {
	            throw new TypeError('parameter 1 is not of type "Element".');
	        }

	        var targets = this._targets;

	        // Do nothing if element is already being observed.
	        if (targets.has(target)) {
	            return;
	        }

	        // Register new ResizeObservation instance.
	        targets.set(target, new ResizeObservation(target));

	        // Add observer to controller if it hasn't been connected yet.
	        if (!this._controller.isConnected(this)) {
	            this._controller.connect(this);
	        }

	        // Update observations.
	        this._controller.refresh();
	    };

	    /**
	     * Stops observing provided element.
	     *
	     * @param {Element} target - Element to stop observing.
	     */
	    ResizeObserver.prototype.unobserve = function unobserve(target) {
	        if (!arguments.length) {
	            throw new TypeError('1 argument required, but only 0 present.');
	        }

	        // Do nothing if current environment doesn't have the Element interface.
	        if (!('Element' in global$1) || !(Element instanceof Object)) {
	            return;
	        }

	        if (!(target instanceof Element)) {
	            throw new TypeError('parameter 1 is not of type "Element".');
	        }

	        var targets = this._targets;

	        // Do nothing if element is not being observed.
	        if (!targets.has(target)) {
	            return;
	        }

	        // Remove element and associated with it ResizeObsrvation instance from
	        // registry.
	        targets.delete(target);

	        // Set back the initial state if there is nothing to observe.
	        if (!targets.size) {
	            this.disconnect();
	        }
	    };

	    /**
	     * Stops observing all elements and clears the observations list.
	     */
	    ResizeObserver.prototype.disconnect = function disconnect() {
	        this.clearActive();
	        this._targets.clear();
	        this._controller.disconnect(this);
	    };

	    /**
	     * Clears an array of previously collected active observations and collects
	     * observation instances which associated element has changed its' content
	     * rectangle.
	     */
	    ResizeObserver.prototype.gatherActive = function gatherActive() {
	        this.clearActive();

	        var activeTargets = this._activeTargets;

	        this._targets.forEach(function (observation) {
	            if (observation.isActive()) {
	                activeTargets.push(observation);
	            }
	        });
	    };

	    /**
	     * Invokes initial callback function with a list of ResizeObserverEntry
	     * instances collected from active resize observations.
	     */
	    ResizeObserver.prototype.broadcastActive = function broadcastActive() {
	        // Do nothing if observer doesn't have active observations.
	        if (!this.hasActive()) {
	            return;
	        }

	        var observer = this._publicObserver;

	        // Create ResizeObserverEntry instance for every active observation.
	        var entries = this._activeTargets.map(function (observation) {
	            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
	        });

	        this.clearActive();
	        this._callback.call(observer, entries, observer);
	    };

	    /**
	     * Clears the collection of pending/active observations.
	     */
	    ResizeObserver.prototype.clearActive = function clearActive() {
	        this._activeTargets.splice(0);
	    };

	    /**
	     * Tells whether observer has pending observations.
	     *
	     * @returns {Boolean}
	     */
	    ResizeObserver.prototype.hasActive = function hasActive() {
	        return !!this._activeTargets.length;
	    };

	    return ResizeObserver;
	}();

	/**
	 * A shim for requestAnimationFrame which falls back
	 * to setTimeout if the first one is not supported.
	 *
	 * @returns {Number} Requests' identifier.
	 */
	var requestAnimFrame = (function () {
	    if (typeof requestAnimationFrame === 'function') {
	        return requestAnimationFrame;
	    }

	    return function (callback) {
	        return setTimeout(function () {
	            return callback(Date.now());
	        }, 1000 / 60);
	    };
	})();

	/**
	 * Creates a wrapper function that ensures that provided callback will
	 * be invoked only once during the specified delay period. It caches the last
	 * call and re-invokes it after pending activation is resolved.
	 *
	 * @param {Function} callback - Function to be invoked after the delay period.
	 * @param {Number} [delay = 0] - Delay after which to invoke callback.
	 * @param {Boolean} [afterRAF = false] - Whether function needs to be invoked as
	 *      a requestAnimationFrame callback.
	 * @returns {Function}
	 */
	var throttle = function (callback) {
	    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var afterRAF = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	    var leadCall = null,
	        edgeCall = null;

	    /**
	     * Invokes the original callback function and schedules a new invocation if
	     * the wrapper was called during current request.
	     */
	    function invokeCallback() {
	        // Invoke original function.
	        callback.apply.apply(callback, leadCall);

	        leadCall = null;

	        // Schedule new invocation if there was a call during delay period.
	        if (edgeCall) {
	            proxy.apply.apply(proxy, edgeCall);

	            edgeCall = null;
	        }
	    }

	    /**
	     * Callback that will be invoked after the specified delay period. It will
	     * delegate invocation of the original function to the requestAnimationFrame
	     * if "afterRAF" parameter is set to "true".
	     */
	    function timeoutCallback() {
	        afterRAF ? requestAnimFrame(invokeCallback) : invokeCallback();
	    }

	    /**
	     * Schedules invocation of the initial function.
	     */
	    function proxy() {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        // eslint-disable-next-line no-invalid-this
	        var callData = [this, args];

	        // Cache current call to be re-invoked later if there is already a
	        // pending call.
	        if (leadCall) {
	            edgeCall = callData;
	        } else {
	            leadCall = callData;

	            // Schedule new invocation.
	            setTimeout(timeoutCallback, delay);
	        }
	    }

	    return proxy;
	};

	// Define whether the MutationObserver is supported.
	var mutationsSupported = typeof MutationObserver === 'function';

	/**
	 * Controller class which handles updates of ResizeObserver instances.
	 * It decides when and for how long it's necessary to run updates by listening
	 * to the windows "resize" event along with a tracking of DOM mutations
	 * (nodes removal, changes of attributes, etc.).
	 *
	 * Transitions and animations are handled by running a repeatable update cycle
	 * until the dimensions of observed elements are changing.
	 *
	 * Continuous update cycle will be used automatically in case MutationObserver
	 * is not supported.
	 */
	var ResizeObserverController = function () {
	    /**
	     * Creates a new instance of ResizeObserverController.
	     *
	     * @param {Boolean} [continuousUpdates = false] - Whether to use a continuous
	     *      update cycle.
	     */
	    function ResizeObserverController() {
	        var continuousUpdates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	        classCallCheck(this, ResizeObserverController);

	        // Continuous updates must be enabled if MutationObserver is not supported.
	        this._isCycleContinuous = !mutationsSupported || continuousUpdates;

	        // Indicates whether DOM listeners have been added.
	        this._listenersEnabled = false;

	        // Keeps reference to the instance of MutationObserver.
	        this._mutationsObserver = null;

	        // A list of connected observers.
	        this._observers = [];

	        // Make sure that the "refresh" method is invoked as a RAF callback and
	        // that it happens only once during the period of 30 milliseconds.
	        this.refresh = throttle(this.refresh.bind(this), 30, true);

	        // Additionally postpone invocation of the continuous updates.
	        this._continuousUpdateHandler = throttle(this.refresh, 70);
	    }

	    /**
	     * Adds observer to observers list.
	     *
	     * @param {ResizeObserver} observer - Observer to be added.
	     */
	    ResizeObserverController.prototype.connect = function connect(observer) {
	        if (!this.isConnected(observer)) {
	            this._observers.push(observer);
	        }

	        // Add listeners if they haven't been added yet.
	        if (!this._listenersEnabled) {
	            this._addListeners();
	        }
	    };

	    /**
	     * Removes observer from observers list.
	     *
	     * @param {ResizeObserver} observer - Observer to be removed.
	     */
	    ResizeObserverController.prototype.disconnect = function disconnect(observer) {
	        var observers = this._observers;
	        var index = observers.indexOf(observer);

	        // Remove observer if it's present in registry.
	        if (~index) {
	            observers.splice(index, 1);
	        }

	        // Remove listeners if controller has no connected observers.
	        if (!observers.length && this._listenersEnabled) {
	            this._removeListeners();
	        }
	    };

	    /**
	     * Tells whether the provided observer is connected to controller.
	     *
	     * @param {ResizeObserver} observer - Observer to be checked.
	     * @returns {Boolean}
	     */
	    ResizeObserverController.prototype.isConnected = function isConnected(observer) {
	        return !!~this._observers.indexOf(observer);
	    };

	    /**
	     * Invokes the update of observers. It will continue running updates insofar
	     * it detects changes or if continuous updates are enabled.
	     */
	    ResizeObserverController.prototype.refresh = function refresh() {
	        var hasChanges = this._updateObservers();

	        // Continue running updates if changes have been detected as there might
	        // be future ones caused by CSS transitions.
	        if (hasChanges) {
	            this.refresh();
	        } else if (this._isCycleContinuous && this._listenersEnabled) {
	            // Automatically repeat cycle if it's necessary.
	            this._continuousUpdateHandler();
	        }
	    };

	    /**
	     * Updates every observer from observers list and notifies them of queued
	     * entries.
	     *
	     * @private
	     * @returns {Boolean} Returns "true" if any observer has detected changes in
	     *      dimensions of its' elements.
	     */
	    ResizeObserverController.prototype._updateObservers = function _updateObservers() {
	        var hasChanges = false;

	        for (var _iterator = this._observers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;

	            if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref = _iterator[_i++];
	            } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref = _i.value;
	            }

	            var observer = _ref;

	            // Collect active observations.
	            observer.gatherActive();

	            // Broadcast active observations and set the flag that changes have
	            // been detected.
	            if (observer.hasActive()) {
	                hasChanges = true;

	                observer.broadcastActive();
	            }
	        }

	        return hasChanges;
	    };

	    /**
	     * Initializes DOM listeners.
	     *
	     * @private
	     */
	    ResizeObserverController.prototype._addListeners = function _addListeners() {
	        // Do nothing if running in a non-browser environment or if listeners
	        // have been already added.
	        if (!isBrowser || this._listenersEnabled) {
	            return;
	        }

	        window.addEventListener('resize', this.refresh);

	        // Subscribe to DOM mutations if it's possible as they may lead to
	        // changes in the dimensions of elements.
	        if (mutationsSupported) {
	            this._mutationsObserver = new MutationObserver(this.refresh);

	            this._mutationsObserver.observe(document, {
	                attributes: true,
	                childList: true,
	                characterData: true,
	                subtree: true
	            });
	        }

	        this._listenersEnabled = true;

	        // Don't wait for a possible event that might trigger the update of
	        // observers and manually initiate the update process.
	        if (this._isCycleContinuous) {
	            this.refresh();
	        }
	    };

	    /**
	     * Removes DOM listeners.
	     *
	     * @private
	     */
	    ResizeObserverController.prototype._removeListeners = function _removeListeners() {
	        // Do nothing if running in a non-browser environment or if listeners
	        // have been already removed.
	        if (!isBrowser || !this._listenersEnabled) {
	            return;
	        }

	        window.removeEventListener('resize', this.refresh);

	        if (this._mutationsObserver) {
	            this._mutationsObserver.disconnect();
	        }

	        this._mutationsObserver = null;
	        this._listenersEnabled = false;
	    };

	    createClass(ResizeObserverController, [{
	        key: 'continuousUpdates',

	        /**
	         * Tells whether continuous updates are enabled.
	         *
	         * @returns {Boolean}
	         */
	        get: function get() {
	            return this._isCycleContinuous;
	        },

	        /**
	         * Enables or disables continuous updates.
	         *
	         * @param {Boolean} useContinuous - Whether to enable or disable continuous
	         *      updates. Note that the value won't be applied if MutationObserver is
	         *      not supported.
	         */
	        set: function set(useContinuous) {
	            // The state of continuous updates should not be modified if
	            // MutationObserver is not supported.
	            if (!mutationsSupported) {
	                return;
	            }

	            this._isCycleContinuous = useContinuous;

	            // Immediately start the update cycle in order not to wait for a possible
	            // event that might initiate it.
	            if (this._listenersEnabled && useContinuous) {
	                this.refresh();
	            }
	        }
	    }]);
	    return ResizeObserverController;
	}();

	// Controller that will be assigned to all instances of ResizeObserver.
	var controller = new ResizeObserverController();

	// Registry of the internal observers.
	var observers = new WeakMap();

	/**
	 * ResizeObservers' "Proxy" class which is meant to hide private properties and
	 * methods from public instances.
	 *
	 * Additionally implements the "continuousUpdates" static property accessor to
	 * give control over the behavior of the ResizeObserverController instance.
	 * Changes made to this property affect all future and existing observers.
	 */
	var ResizeObserver = function () {
	    /**
	     * Creates a new instance of ResizeObserver.
	     *
	     * @param {Function} callback - Callback that is invoked when dimensions of
	     *      one of the observed elements change.
	     */
	    function ResizeObserver(callback) {
	        classCallCheck(this, ResizeObserver);

	        if (!arguments.length) {
	            throw new TypeError('1 argument required, but only 0 present.');
	        }

	        // Create a new instance of the internal ResizeObserver.
	        var observer = new ResizeObserver$2(callback, controller, this);

	        // Register internal observer.
	        observers.set(this, observer);
	    }

	    createClass(ResizeObserver, null, [{
	        key: 'continuousUpdates',

	        /**
	         * Tells whether continuous updates are enabled.
	         *
	         * @returns {Boolean}
	         */
	        get: function get() {
	            return controller.continuousUpdates;
	        },

	        /**
	         * Enables or disables continuous updates.
	         *
	         * @param {Boolean} value - Whether to enable or disable continuous updates.
	         */
	        set: function set(value) {
	            if (typeof value !== 'boolean') {
	                throw new TypeError('type of "continuousUpdates" value must be boolean.');
	            }

	            controller.continuousUpdates = value;
	        }
	    }]);
	    return ResizeObserver;
	}();

	// Expose public methods of ResizeObserver.
	['observe', 'unobserve', 'disconnect'].forEach(function (method) {
	    ResizeObserver.prototype[method] = function () {
	        var _observers$get;

	        return (_observers$get = observers.get(this))[method].apply(_observers$get, arguments);
	    };
	});

	var index = (function () {
	    // Export existing implementation if it's available.
	    if (typeof global$1.ResizeObserver === 'function') {
	        return global$1.ResizeObserver;
	    }

	    return ResizeObserver;
	})();

	return index;
	})));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 13 */
/***/ function(module, exports) {

	/* eslint-disable no-undefined,no-param-reassign,no-shadow */

	/**
	 * Throttle execution of a function. Especially useful for rate limiting
	 * execution of handlers on events like resize and scroll.
	 *
	 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
	 * @param  {Boolean}   noTrailing     Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
	 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
	 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
	 *                                    the internal counter is reset)
	 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
	 *                                    to `callback` when the throttled-function is executed.
	 * @param  {Boolean}   debounceMode   If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
	 *                                    schedule `callback` to execute after `delay` ms.
	 *
	 * @return {Function}  A new, throttled, function.
	 */
	module.exports = function ( delay, noTrailing, callback, debounceMode ) {

		// After wrapper has stopped being called, this timeout ensures that
		// `callback` is executed at the proper times in `throttle` and `end`
		// debounce modes.
		var timeoutID;

		// Keep track of the last time `callback` was executed.
		var lastExec = 0;

		// `noTrailing` defaults to falsy.
		if ( typeof noTrailing !== 'boolean' ) {
			debounceMode = callback;
			callback = noTrailing;
			noTrailing = undefined;
		}

		// The `wrapper` function encapsulates all of the throttling / debouncing
		// functionality and when executed will limit the rate at which `callback`
		// is executed.
		function wrapper () {

			var self = this;
			var elapsed = Number(new Date()) - lastExec;
			var args = arguments;

			// Execute `callback` and update the `lastExec` timestamp.
			function exec () {
				lastExec = Number(new Date());
				callback.apply(self, args);
			}

			// If `debounceMode` is true (at begin) this is used to clear the flag
			// to allow future `callback` executions.
			function clear () {
				timeoutID = undefined;
			}

			if ( debounceMode && !timeoutID ) {
				// Since `wrapper` is being called for the first time and
				// `debounceMode` is true (at begin), execute `callback`.
				exec();
			}

			// Clear any existing timeout.
			if ( timeoutID ) {
				clearTimeout(timeoutID);
			}

			if ( debounceMode === undefined && elapsed > delay ) {
				// In throttle mode, if `delay` time has been exceeded, execute
				// `callback`.
				exec();

			} else if ( noTrailing !== true ) {
				// In trailing throttle mode, since `delay` time has not been
				// exceeded, schedule `callback` to execute `delay` ms after most
				// recent execution.
				//
				// If `debounceMode` is true (at begin), schedule `clear` to execute
				// after `delay` ms.
				//
				// If `debounceMode` is false (at end), schedule `callback` to
				// execute after `delay` ms.
				timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
			}

		}

		// Return the wrapper function.
		return wrapper;

	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _utilities = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ScrollLink = function (_Component) {
	  _inherits(ScrollLink, _Component);

	  function ScrollLink() {
	    _classCallCheck(this, ScrollLink);

	    return _possibleConstructorReturn(this, (ScrollLink.__proto__ || Object.getPrototypeOf(ScrollLink)).apply(this, arguments));
	  }

	  _createClass(ScrollLink, [{
	    key: 'handleClick',
	    value: function handleClick(e) {
	      if (this.props.onClick) {
	        this.props.onClick(e);
	      }

	      e.preventDefault();
	      e.stopPropagation();

	      this.context.scroll.scrollTo(this.props.to);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var style = _extends({
	        cursor: 'pointer'
	      }, this.props.style);
	      // Fixes unknown props on <div> tag

	      var _props = this.props,
	          to = _props.to,
	          props = _objectWithoutProperties(_props, ['to']);

	      return _react2.default.createElement('a', _extends({}, props, { style: style, onClick: this.handleClick.bind(this) }));
	    }
	  }]);

	  return ScrollLink;
	}(_react.Component);

	ScrollLink.contextTypes = {
	  scroll: _utilities.contextProviderShape
	};
	exports.default = ScrollLink;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactMotion = __webpack_require__(11);

	var _throttleDebounce = __webpack_require__(28);

	var _resizeObserverPolyfill = __webpack_require__(12);

	var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

	var _utilities = __webpack_require__(2);

	var _contextProviderShape = __webpack_require__(4);

	var _contextProviderShape2 = _interopRequireDefault(_contextProviderShape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/** Notes
	## References:
	- https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e#.2cnfo15to
	- https://github.com/souporserious/react-measure/blob/master/src/Measure.jsx
	- https://github.com/ReactTraining/react-router/blob/master/modules/Link.js
	- https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html#context
	- https://css-tricks.com/snippets/jquery/smooth-scrolling/
	- https://github.com/callmecavs/jump.js
	- https://github.com/jlmakes/scrollreveal
	- https://www.youtube.com/watch?v=rNsC1VI9388

	## TODO:
	findChildByposition()

	child methods
	- onMove()
	- onRest()

	**/

	var ScrollProvider = function (_Component) {
	  _inherits(ScrollProvider, _Component);

	  function ScrollProvider(props) {
	    _classCallCheck(this, ScrollProvider);

	    var _this = _possibleConstructorReturn(this, (ScrollProvider.__proto__ || Object.getPrototypeOf(ScrollProvider)).call(this, props));

	    _this.state = {
	      position: 0,
	      positionRatio: 0,
	      start: 0,
	      end: 0,
	      viewHeight: 0,
	      scrollHeight: 0,
	      ready: false,
	      onStart: true,
	      onMiddle: false,
	      onEnd: false,
	      children: [],
	      autoFrame: props.autoFrame,
	      autoScroll: props.autoScroll,
	      originalPosition: null,
	      changedPosition: null,
	      timeStamp: null,
	      scrolling: false,
	      wheeling: false,
	      touching: false,
	      moving: false,
	      resting: true,
	      touches: []
	    };

	    _this.node = null;

	    // debounce is used to mimiques start, move and end events that don't have this functions
	    _this.handleScrollStart = (0, _throttleDebounce.debounce)(500, true, _this.handleScrollStart);
	    _this.handleResizeMove = (0, _throttleDebounce.throttle)(50, _this.handleResizeMove);
	    _this.handleScrollEnd = (0, _throttleDebounce.debounce)(500, _this.handleScrollEnd);
	    _this.handleWheelStart = (0, _throttleDebounce.debounce)(250, true, _this.handleWheelStart);
	    _this.handleWheelEnd = (0, _throttleDebounce.debounce)(250, _this.handleWheelEnd);
	    _this.handleResizeStart = (0, _throttleDebounce.debounce)(250, true, _this.handleResizeStart);
	    _this.handleResizeEnd = (0, _throttleDebounce.debounce)(250, _this.handleResizeEnd);
	    return _this;
	  }

	  _createClass(ScrollProvider, [{
	    key: 'setNode',
	    value: function setNode(node) {
	      var _this2 = this;

	      this.node = node;

	      // add component to resize observer to detect changes on resize
	      this.resizeObserver = new _resizeObserverPolyfill2.default(function (entries, observer) {
	        if (_this2.state.ready) {
	          _this2.handleResize();
	        } else {
	          _this2.setStateScroll({
	            ready: true
	          });
	        }
	      });

	      this.resizeObserver.observe(this.node);
	    }
	  }, {
	    key: 'unsetNode',
	    value: function unsetNode() {
	      this.node = null;
	      this.resizeObserver.disconnect(this.context.scroll.node);

	      this.setState({
	        ready: true
	      });
	    }
	  }, {
	    key: 'setStateScroll',
	    value: function setStateScroll(additionalStates) {
	      this.setState(_extends({}, (0, _utilities.nodeToScrollState)(this.node), (0, _utilities.nodeChildrenToScrollState)(this.node), additionalStates));
	    }
	  }, {
	    key: 'setStateStart',
	    value: function setStateStart(additionalStates) {
	      this.setState(_extends({
	        originalPosition: this.state.position,
	        timeStamp: Date.now()
	      }, additionalStates));
	    }
	  }, {
	    key: 'setStateMove',
	    value: function setStateMove(additionalStates) {
	      this.setState(_extends({
	        moving: true,
	        resting: false
	      }, additionalStates));
	    }
	  }, {
	    key: 'setStateRest',
	    value: function setStateRest(additionalStates) {
	      this.setState(_extends({
	        moving: false,
	        resting: true
	      }, additionalStates));
	    }
	  }, {
	    key: 'setStateEnd',
	    value: function setStateEnd(additionalStates) {
	      this.setState(_extends({
	        originalPosition: null,
	        changedPosition: null,
	        timeStamp: null
	      }, additionalStates));
	    }
	  }, {
	    key: 'setStateIfElseMove',
	    value: function setStateIfElseMove(additionalStates) {
	      var notMoved = this.state.originalPosition === this.state.position;

	      if (notMoved) {
	        // this.setStateRest(additionalStates)
	      } else {
	          // this.setState(additionalStates)
	        }
	    }
	  }, {
	    key: 'findChildByName',
	    value: function findChildByName(name) {
	      // TODO: log error if not found
	      return this.state.children.find(function (child) {
	        return child.name === name;
	      });
	    }
	  }, {
	    key: 'findChildOnView',
	    value: function findChildOnView() {
	      return this.state.children.find(function (child) {
	        return child.onView;
	      });
	    }
	  }, {
	    key: 'findChildIndexOnView',
	    value: function findChildIndexOnView() {
	      return this.state.children.findIndex(function (child) {
	        return child.onView;
	      });
	    }
	  }, {
	    key: 'scrollTo',
	    value: function scrollTo(target, options) {
	      switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
	        case "number":
	          return this.scrollToPosition(target, options);
	        case "string":
	          return this.scrollToName(target, options);
	        case "object":
	          return this.scrollToElement(target, options);
	      }
	    }
	  }, {
	    key: 'scrollToPosition',
	    value: function scrollToPosition(position) {
	      this.setState({ changedPosition: position });
	    }
	  }, {
	    key: 'scrollToByIndex',
	    value: function scrollToByIndex(index) {
	      var position = this.state.children[index].start;

	      this.scrollTo(position);
	    }
	  }, {
	    key: 'scrollToTop',
	    value: function scrollToTop() {
	      var top = this.state.start;

	      this.scrollToPosition(top);
	    }
	  }, {
	    key: 'scrollToBottom',
	    value: function scrollToBottom() {
	      var bottom = this.state.end;

	      this.scrollToPosition(bottom);
	    }
	  }, {
	    key: 'previousOfIndex',
	    value: function previousOfIndex() {
	      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.findChildIndexOnView();
	      var arr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.children;

	      return arr[i > 0 ? i - 1 : i];
	    }
	  }, {
	    key: 'nextOfIndex',
	    value: function nextOfIndex() {
	      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.findChildIndexOnView();
	      var arr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.children;

	      return arr[i < arr.length - 1 ? i + 1 : i];
	    }
	  }, {
	    key: 'scrollUpwards',
	    value: function scrollUpwards() {
	      var upwardsPosition = this.previousOfIndex().start;

	      this.scrollTo(upwardsPosition);
	    }
	  }, {
	    key: 'scrollDownwards',
	    value: function scrollDownwards() {
	      var downwardsPosition = this.nextOfIndex().start;

	      this.scrollTo(downwardsPosition);
	    }
	  }, {
	    key: 'scrollToName',
	    value: function scrollToName(name) {
	      // TODO: handle fail if it does not exist
	      var child = this.findChildByName(name);

	      this.scrollToPosition(child.start);
	    }
	  }, {
	    key: 'scrollToElement',
	    value: function scrollToElement(element, options) {
	      var start = element.scrollTop;

	      this.scrollToPosition(start);
	    }
	  }, {
	    key: 'scrollToActive',
	    value: function scrollToActive() {
	      var newPosition = this.findChildOnView().start;

	      this.scrollToPosition(newPosition);
	    }
	  }, {
	    key: 'handleScroll',
	    value: function handleScroll() {
	      this.handleScrollStart();
	      this.handleScrollMove();
	      this.handleScrollEnd();
	    }
	  }, {
	    key: 'handleScrollStart',
	    value: function handleScrollStart() {
	      this.setStateMove();
	    }
	  }, {
	    key: 'handleScrollMove',
	    value: function handleScrollMove() {
	      this.setStateScroll();
	    }
	  }, {
	    key: 'handleScrollEnd',
	    value: function handleScrollEnd() {
	      this.setStateRest();
	    }
	  }, {
	    key: 'handleResize',
	    value: function handleResize() {

	      this.handleResizeStart();
	      this.handleResizeMove();
	      this.handleResizeEnd();
	    }
	  }, {
	    key: 'handleResizeStart',
	    value: function handleResizeStart() {
	      console.log('handleResizeStart');
	      this.setStateMove();
	    }
	  }, {
	    key: 'handleResizeMove',
	    value: function handleResizeMove() {
	      console.log('handleResizeMove');
	      this.handleScroll();
	    }
	  }, {
	    key: 'handleResizeEnd',
	    value: function handleResizeEnd() {
	      console.log('handleResizeEnd');
	      if (this.state.autoFrame) this.scrollToActive();
	    }
	  }, {
	    key: 'handleWheel',
	    value: function handleWheel(e) {
	      if (this.state.autoScroll) e.preventDefault();
	      this.handleWheelStart(e);
	      this.handleWheelMove(e);
	      this.handleWheelEnd(e);
	    }
	  }, {
	    key: 'handleWheelStart',
	    value: function handleWheelStart(e) {
	      this.setStateStart({
	        wheeling: true,
	        changedPosition: !this.state.autoScroll ? null : this.state.changedPosition
	      });

	      if (this.state.autoScroll) {
	        var movingUpwards = e.deltaY > 0;
	        var movingDownwards = e.deltaY < 0;

	        if (movingDownwards) this.scrollUpwards();
	        if (movingUpwards) this.scrollDownwards();
	      }
	    }
	  }, {
	    key: 'handleWheelMove',
	    value: function handleWheelMove(e) {
	      // let prevDeltaY = this.state.deltaY || 0
	      // let nextDeltaY = prevDeltaY + e.deltaY
	      //
	      // this.setState({
	      //   deltaY: nextDeltaY
	      // })
	      //
	      // const scrollPosition = this.state.originalPosition + nextDeltaY
	      //
	      // this.scrollTo(scrollPosition)
	    }
	  }, {
	    key: 'handleWheelEnd',
	    value: function handleWheelEnd(e) {
	      this.setStateEnd({
	        wheeling: false,
	        deltaY: null
	      });

	      if (this.state.autoFrame) this.scrollToActive();
	    }
	  }, {
	    key: 'handleTouchStart',
	    value: function handleTouchStart(e) {
	      this.setStateStart({
	        touching: true,
	        touches: e.touches
	      });
	    }
	  }, {
	    key: 'handleTouchMove',
	    value: function handleTouchMove(e) {
	      var distanceFromTouchStart = e.changedTouches[0].clientY - this.state.touches[0].clientY;
	      var touchPosition = this.state.originalPosition - distanceFromTouchStart;

	      this.scrollToPosition(touchPosition);
	    }
	  }, {
	    key: 'handleTouchEnd',
	    value: function handleTouchEnd(e) {
	      var timeLapse = Date.now() - this.state.timeStamp;

	      if (timeLapse < 200) {
	        var movingUpwards = e.changedTouches[0].clientY < this.state.touches[0].clientY;
	        var movingDownwards = e.changedTouches[0].clientY > this.state.touches[0].clientY;

	        if (movingDownwards) this.scrollUpwards();
	        if (movingUpwards) this.scrollDownwards();
	      } else {
	        this.scrollToActive();
	      }

	      this.setState({
	        touching: false
	      });
	    }
	  }, {
	    key: 'getChildContext',
	    value: function getChildContext() {
	      return {
	        scroll: _extends({}, this.state, {
	          node: this.node,
	          setNode: this.setNode.bind(this),
	          unsetNode: this.unsetNode.bind(this),
	          handleScroll: this.handleScroll.bind(this),
	          handleWheel: this.handleWheel.bind(this),
	          handleTouchStart: this.handleTouchStart.bind(this),
	          handleTouchMove: this.handleTouchMove.bind(this),
	          handleTouchEnd: this.handleTouchEnd.bind(this),
	          scrollTo: this.scrollTo.bind(this),
	          scrollToPosition: this.scrollToPosition.bind(this),
	          scrollToByIndex: this.scrollToByIndex.bind(this),
	          scrollToName: this.scrollToName.bind(this),
	          scrollToTop: this.scrollToTop.bind(this),
	          scrollToBottom: this.scrollToBottom.bind(this),
	          scrollToElement: this.scrollToElement.bind(this),
	          scrollToActive: this.scrollToActive.bind(this),
	          findChildByName: this.findChildByName.bind(this),
	          findChildOnView: this.findChildOnView.bind(this),
	          findChildIndexOnView: this.findChildIndexOnView.bind(this)
	        })
	      };
	    }
	  }, {
	    key: 'getContextToProps',
	    value: function getContextToProps() {
	      // filter context of helper states and methods
	      var _getChildContext$scro = this.getChildContext().scroll,
	          originalPosition = _getChildContext$scro.originalPosition,
	          changedPosition = _getChildContext$scro.changedPosition,
	          timeStamp = _getChildContext$scro.timeStamp,
	          autoFrame = _getChildContext$scro.autoFrame,
	          autoScroll = _getChildContext$scro.autoScroll,
	          node = _getChildContext$scro.node,
	          setNode = _getChildContext$scro.setNode,
	          unsetNode = _getChildContext$scro.unsetNode,
	          handleScroll = _getChildContext$scro.handleScroll,
	          handleWheel = _getChildContext$scro.handleWheel,
	          handleTouchStart = _getChildContext$scro.handleTouchStart,
	          handleTouchMove = _getChildContext$scro.handleTouchMove,
	          handleTouchEnd = _getChildContext$scro.handleTouchEnd,
	          remainingContext = _objectWithoutProperties(_getChildContext$scro, ['originalPosition', 'changedPosition', 'timeStamp', 'autoFrame', 'autoScroll', 'node', 'setNode', 'unsetNode', 'handleScroll', 'handleWheel', 'handleTouchStart', 'handleTouchMove', 'handleTouchEnd']);

	      return {
	        scroll: remainingContext
	      };
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.cloneElement(this.props.children, this.getContextToProps());
	    }
	  }]);

	  return ScrollProvider;
	}(_react.Component);

	ScrollProvider.childContextTypes = {
	  scroll: _contextProviderShape2.default
	};
	ScrollProvider.defaultProps = {
	  autoFrame: false,
	  autoScroll: false
	};
	exports.default = ScrollProvider;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(29);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _reactMotion = __webpack_require__(11);

	var _resizeObserverPolyfill = __webpack_require__(12);

	var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

	var _utilities = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// import { throttle } from 'throttle-debounce'


	var Scroller = function (_Component) {
	  _inherits(Scroller, _Component);

	  function Scroller() {
	    _classCallCheck(this, Scroller);

	    return _possibleConstructorReturn(this, (Scroller.__proto__ || Object.getPrototypeOf(Scroller)).apply(this, arguments));
	  }

	  _createClass(Scroller, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var node = _reactDom2.default.findDOMNode(this);

	      // sets node in ScrollProdiver
	      this.context.scroll.setNode(node);
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.context.scroll.unsetNode();
	    }
	  }, {
	    key: 'handleScroll',
	    value: function handleScroll(e) {
	      if (this.props.handleScroll) this.props.handleScroll(e);
	      this.context.scroll.handleScroll(e);
	    }
	  }, {
	    key: 'handleWheel',
	    value: function handleWheel(e) {
	      if (this.props.handleWheel) this.props.handleWheel(e);
	      this.context.scroll.handleWheel(e);
	    }
	  }, {
	    key: 'handleTouchStart',
	    value: function handleTouchStart(e) {
	      if (this.props.handleTouchStart) this.props.handleTouchStart(e);
	      this.context.scroll.handleTouchStart(e);
	    }
	  }, {
	    key: 'handleTouchMove',
	    value: function handleTouchMove(e) {
	      if (this.props.handleTouchMove) this.props.handleTouchMove(e);
	      this.context.scroll.handleTouchMove(e);
	    }
	  }, {
	    key: 'handleTouchEnd',
	    value: function handleTouchEnd(e) {
	      if (this.props.handleTouchEnd) this.props.handleTouchEnd(e);
	      this.context.scroll.handleTouchEnd(e);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var _context$scroll = this.context.scroll,
	          node = _context$scroll.node,
	          position = _context$scroll.position,
	          changedPosition = _context$scroll.changedPosition,
	          touching = _context$scroll.touching,
	          autoScroll = _context$scroll.autoScroll;


	      var style = _extends({
	        height: '100%',
	        width: '100%',
	        overflowScrolling: 'touch',
	        WebkitOverflowScrolling: 'touch',
	        // TODO: investigar glich on touchScroll with overFlow
	        // overflowY: !autoScroll && !touching ? 'auto' : 'hidden',
	        overflowY: autoScroll || touching ? 'hidden' : 'auto'
	      }, this.props.style);

	      return _react2.default.createElement(
	        _reactMotion.Motion,
	        {
	          style: {
	            positionSpring: changedPosition !== null ? (0, _reactMotion.spring)(changedPosition) : position
	          }
	        },
	        function (_ref) {
	          var positionSpring = _ref.positionSpring;

	          if (node && changedPosition !== null) {
	            node.scrollTop = Math.round(positionSpring);
	          }

	          return _react2.default.createElement('div', _extends({}, _this2.props, {
	            style: style,
	            onScroll: _this2.handleScroll.bind(_this2),
	            onWheel: _this2.handleWheel.bind(_this2),
	            onTouchStart: _this2.handleTouchStart.bind(_this2),
	            onTouchMove: _this2.handleTouchMove.bind(_this2),
	            onTouchEnd: _this2.handleTouchEnd.bind(_this2)
	          }));
	        }
	      );
	    }
	  }]);

	  return Scroller;
	}(_react.Component);

	Scroller.contextTypes = {
	  scroll: _utilities.contextProviderShape
	};
	Scroller.propTypes = {
	  children: _react.PropTypes.arrayOf(_react.PropTypes.element).isRequired
	};
	exports.default = Scroller;

/***/ },
/* 17 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeChildrenToScrollState;
	function nodeChildrenToScrollState(_ref) {
	  var children = _ref.children,
	      scrollTop = _ref.scrollTop;

	  var list = [];

	  // used to increment children view heights
	  var start = 0;

	  // Fix: default props
	  // let { theshold } = this.props
	  var theshold = 0.5;

	  // TODO: experiment a map
	  for (var i = 0; i < children.length; i++) {
	    var _children$i = children[i],
	        offsetHeight = _children$i.offsetHeight,
	        attributes = _children$i.attributes;

	    // interpreting native values

	    var viewHeight = offsetHeight;
	    var end = start + viewHeight;

	    // current position values
	    var position = start - scrollTop;
	    var positionRatio = position / offsetHeight;
	    var positionRatioRemainer = positionRatio <= -1 ? 1 : positionRatio >= 1 ? 1 : Math.abs(positionRatio % 1);

	    /* Used for creating navigations and  to links to
	    *  <Link to="Home" />
	    */
	    var name = attributes.name ? attributes.name.value : null;

	    // Conditionals
	    // FIX: use exact values
	    var onView = positionRatio <= theshold && positionRatio >= -theshold;
	    var onFrame = position === scrollTop;
	    // TODO: review active
	    // TODO: addfunction to run on activate()
	    var active = onView;

	    list.push({ name: name, position: position, positionRatio: positionRatio, positionRatioRemainer: positionRatioRemainer, start: start, end: end, viewHeight: viewHeight, onView: onView, active: active, onFrame: onFrame });

	    // increament based on stacked item's height
	    start += offsetHeight;
	  }

	  return { children: list };
	}

/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = nodeToScrollState;
	function nodeToScrollState(_ref) {
	  var scrollTop = _ref.scrollTop,
	      scrollHeight = _ref.scrollHeight,
	      offsetHeight = _ref.offsetHeight;

	  // Interpreting native values
	  var start = 0;
	  var viewHeight = offsetHeight;
	  var end = scrollHeight - viewHeight;

	  // current position
	  var position = scrollTop;
	  var positionRatio = scrollTop / end;

	  // Conditionals
	  var onStart = position <= start;
	  var onEnd = position >= end;
	  var onMiddle = !onStart && !onEnd;

	  // let scrolling = true / false

	  return { position: position, positionRatio: positionRatio, start: start, end: end, viewHeight: viewHeight, scrollHeight: scrollHeight, onStart: onStart, onMiddle: onMiddle, onEnd: onEnd };
	}

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	exports.default = scrollConnect;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _contextProviderShape = __webpack_require__(4);

	var _contextProviderShape2 = _interopRequireDefault(_contextProviderShape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function scrollConnect(WrappedComponent) {
	  var _class, _temp;

	  return _temp = _class = function (_WrappedComponent) {
	    _inherits(WrappedWithScrollConnect, _WrappedComponent);

	    function WrappedWithScrollConnect() {
	      _classCallCheck(this, WrappedWithScrollConnect);

	      return _possibleConstructorReturn(this, (WrappedWithScrollConnect.__proto__ || Object.getPrototypeOf(WrappedWithScrollConnect)).apply(this, arguments));
	    }

	    _createClass(WrappedWithScrollConnect, [{
	      key: 'render',
	      value: function render() {
	        this.props = _extends({}, this.props, this.context);

	        return _get(WrappedWithScrollConnect.prototype.__proto__ || Object.getPrototypeOf(WrappedWithScrollConnect.prototype), 'render', this).call(this);
	      }
	    }]);

	    return WrappedWithScrollConnect;
	  }(WrappedComponent), _class.contextTypes = {
	    scroll: _contextProviderShape2.default
	  }, _temp;
	}

/***/ },
/* 20 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mapToZero = __webpack_require__(6);

	var _mapToZero2 = _interopRequireDefault(_mapToZero);

	var _stripStyle = __webpack_require__(9);

	var _stripStyle2 = _interopRequireDefault(_stripStyle);

	var _stepper3 = __webpack_require__(8);

	var _stepper4 = _interopRequireDefault(_stepper3);

	var _performanceNow = __webpack_require__(3);

	var _performanceNow2 = _interopRequireDefault(_performanceNow);

	var _raf = __webpack_require__(5);

	var _raf2 = _interopRequireDefault(_raf);

	var _shouldStopAnimation = __webpack_require__(7);

	var _shouldStopAnimation2 = _interopRequireDefault(_shouldStopAnimation);

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var msPerFrame = 1000 / 60;

	var Motion = _react2['default'].createClass({
	  displayName: 'Motion',

	  propTypes: {
	    // TOOD: warn against putting a config in here
	    defaultStyle: _react.PropTypes.objectOf(_react.PropTypes.number),
	    style: _react.PropTypes.objectOf(_react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.object])).isRequired,
	    children: _react.PropTypes.func.isRequired,
	    onRest: _react.PropTypes.func
	  },

	  getInitialState: function getInitialState() {
	    var _props = this.props;
	    var defaultStyle = _props.defaultStyle;
	    var style = _props.style;

	    var currentStyle = defaultStyle || _stripStyle2['default'](style);
	    var currentVelocity = _mapToZero2['default'](currentStyle);
	    return {
	      currentStyle: currentStyle,
	      currentVelocity: currentVelocity,
	      lastIdealStyle: currentStyle,
	      lastIdealVelocity: currentVelocity
	    };
	  },

	  wasAnimating: false,
	  animationID: null,
	  prevTime: 0,
	  accumulatedTime: 0,
	  // it's possible that currentStyle's value is stale: if props is immediately
	  // changed from 0 to 400 to spring(0) again, the async currentStyle is still
	  // at 0 (didn't have time to tick and interpolate even once). If we naively
	  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
	  // In reality currentStyle should be 400
	  unreadPropStyle: null,
	  // after checking for unreadPropStyle != null, we manually go set the
	  // non-interpolating values (those that are a number, without a spring
	  // config)
	  clearUnreadPropStyle: function clearUnreadPropStyle(destStyle) {
	    var dirty = false;
	    var _state = this.state;
	    var currentStyle = _state.currentStyle;
	    var currentVelocity = _state.currentVelocity;
	    var lastIdealStyle = _state.lastIdealStyle;
	    var lastIdealVelocity = _state.lastIdealVelocity;

	    for (var key in destStyle) {
	      if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
	        continue;
	      }

	      var styleValue = destStyle[key];
	      if (typeof styleValue === 'number') {
	        if (!dirty) {
	          dirty = true;
	          currentStyle = _extends({}, currentStyle);
	          currentVelocity = _extends({}, currentVelocity);
	          lastIdealStyle = _extends({}, lastIdealStyle);
	          lastIdealVelocity = _extends({}, lastIdealVelocity);
	        }

	        currentStyle[key] = styleValue;
	        currentVelocity[key] = 0;
	        lastIdealStyle[key] = styleValue;
	        lastIdealVelocity[key] = 0;
	      }
	    }

	    if (dirty) {
	      this.setState({ currentStyle: currentStyle, currentVelocity: currentVelocity, lastIdealStyle: lastIdealStyle, lastIdealVelocity: lastIdealVelocity });
	    }
	  },

	  startAnimationIfNecessary: function startAnimationIfNecessary() {
	    var _this = this;

	    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
	    // call cb? No, otherwise accidental parent rerender causes cb trigger
	    this.animationID = _raf2['default'](function (timestamp) {
	      // check if we need to animate in the first place
	      var propsStyle = _this.props.style;
	      if (_shouldStopAnimation2['default'](_this.state.currentStyle, propsStyle, _this.state.currentVelocity)) {
	        if (_this.wasAnimating && _this.props.onRest) {
	          _this.props.onRest();
	        }

	        // no need to cancel animationID here; shouldn't have any in flight
	        _this.animationID = null;
	        _this.wasAnimating = false;
	        _this.accumulatedTime = 0;
	        return;
	      }

	      _this.wasAnimating = true;

	      var currentTime = timestamp || _performanceNow2['default']();
	      var timeDelta = currentTime - _this.prevTime;
	      _this.prevTime = currentTime;
	      _this.accumulatedTime = _this.accumulatedTime + timeDelta;
	      // more than 10 frames? prolly switched browser tab. Restart
	      if (_this.accumulatedTime > msPerFrame * 10) {
	        _this.accumulatedTime = 0;
	      }

	      if (_this.accumulatedTime === 0) {
	        // no need to cancel animationID here; shouldn't have any in flight
	        _this.animationID = null;
	        _this.startAnimationIfNecessary();
	        return;
	      }

	      var currentFrameCompletion = (_this.accumulatedTime - Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;
	      var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);

	      var newLastIdealStyle = {};
	      var newLastIdealVelocity = {};
	      var newCurrentStyle = {};
	      var newCurrentVelocity = {};

	      for (var key in propsStyle) {
	        if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {
	          continue;
	        }

	        var styleValue = propsStyle[key];
	        if (typeof styleValue === 'number') {
	          newCurrentStyle[key] = styleValue;
	          newCurrentVelocity[key] = 0;
	          newLastIdealStyle[key] = styleValue;
	          newLastIdealVelocity[key] = 0;
	        } else {
	          var newLastIdealStyleValue = _this.state.lastIdealStyle[key];
	          var newLastIdealVelocityValue = _this.state.lastIdealVelocity[key];
	          for (var i = 0; i < framesToCatchUp; i++) {
	            var _stepper = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

	            newLastIdealStyleValue = _stepper[0];
	            newLastIdealVelocityValue = _stepper[1];
	          }

	          var _stepper2 = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

	          var nextIdealX = _stepper2[0];
	          var nextIdealV = _stepper2[1];

	          newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;
	          newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;
	          newLastIdealStyle[key] = newLastIdealStyleValue;
	          newLastIdealVelocity[key] = newLastIdealVelocityValue;
	        }
	      }

	      _this.animationID = null;
	      // the amount we're looped over above
	      _this.accumulatedTime -= framesToCatchUp * msPerFrame;

	      _this.setState({
	        currentStyle: newCurrentStyle,
	        currentVelocity: newCurrentVelocity,
	        lastIdealStyle: newLastIdealStyle,
	        lastIdealVelocity: newLastIdealVelocity
	      });

	      _this.unreadPropStyle = null;

	      _this.startAnimationIfNecessary();
	    });
	  },

	  componentDidMount: function componentDidMount() {
	    this.prevTime = _performanceNow2['default']();
	    this.startAnimationIfNecessary();
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(props) {
	    if (this.unreadPropStyle != null) {
	      // previous props haven't had the chance to be set yet; set them here
	      this.clearUnreadPropStyle(this.unreadPropStyle);
	    }

	    this.unreadPropStyle = props.style;
	    if (this.animationID == null) {
	      this.prevTime = _performanceNow2['default']();
	      this.startAnimationIfNecessary();
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    if (this.animationID != null) {
	      _raf2['default'].cancel(this.animationID);
	      this.animationID = null;
	    }
	  },

	  render: function render() {
	    var renderedChildren = this.props.children(this.state.currentStyle);
	    return renderedChildren && _react2['default'].Children.only(renderedChildren);
	  }
	});

	exports['default'] = Motion;
	module.exports = exports['default'];

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mapToZero = __webpack_require__(6);

	var _mapToZero2 = _interopRequireDefault(_mapToZero);

	var _stripStyle = __webpack_require__(9);

	var _stripStyle2 = _interopRequireDefault(_stripStyle);

	var _stepper3 = __webpack_require__(8);

	var _stepper4 = _interopRequireDefault(_stepper3);

	var _performanceNow = __webpack_require__(3);

	var _performanceNow2 = _interopRequireDefault(_performanceNow);

	var _raf = __webpack_require__(5);

	var _raf2 = _interopRequireDefault(_raf);

	var _shouldStopAnimation = __webpack_require__(7);

	var _shouldStopAnimation2 = _interopRequireDefault(_shouldStopAnimation);

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var msPerFrame = 1000 / 60;

	function shouldStopAnimationAll(currentStyles, styles, currentVelocities) {
	  for (var i = 0; i < currentStyles.length; i++) {
	    if (!_shouldStopAnimation2['default'](currentStyles[i], styles[i], currentVelocities[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	var StaggeredMotion = _react2['default'].createClass({
	  displayName: 'StaggeredMotion',

	  propTypes: {
	    // TOOD: warn against putting a config in here
	    defaultStyles: _react.PropTypes.arrayOf(_react.PropTypes.objectOf(_react.PropTypes.number)),
	    styles: _react.PropTypes.func.isRequired,
	    children: _react.PropTypes.func.isRequired
	  },

	  getInitialState: function getInitialState() {
	    var _props = this.props;
	    var defaultStyles = _props.defaultStyles;
	    var styles = _props.styles;

	    var currentStyles = defaultStyles || styles().map(_stripStyle2['default']);
	    var currentVelocities = currentStyles.map(function (currentStyle) {
	      return _mapToZero2['default'](currentStyle);
	    });
	    return {
	      currentStyles: currentStyles,
	      currentVelocities: currentVelocities,
	      lastIdealStyles: currentStyles,
	      lastIdealVelocities: currentVelocities
	    };
	  },

	  animationID: null,
	  prevTime: 0,
	  accumulatedTime: 0,
	  // it's possible that currentStyle's value is stale: if props is immediately
	  // changed from 0 to 400 to spring(0) again, the async currentStyle is still
	  // at 0 (didn't have time to tick and interpolate even once). If we naively
	  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
	  // In reality currentStyle should be 400
	  unreadPropStyles: null,
	  // after checking for unreadPropStyles != null, we manually go set the
	  // non-interpolating values (those that are a number, without a spring
	  // config)
	  clearUnreadPropStyle: function clearUnreadPropStyle(unreadPropStyles) {
	    var _state = this.state;
	    var currentStyles = _state.currentStyles;
	    var currentVelocities = _state.currentVelocities;
	    var lastIdealStyles = _state.lastIdealStyles;
	    var lastIdealVelocities = _state.lastIdealVelocities;

	    var someDirty = false;
	    for (var i = 0; i < unreadPropStyles.length; i++) {
	      var unreadPropStyle = unreadPropStyles[i];
	      var dirty = false;

	      for (var key in unreadPropStyle) {
	        if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
	          continue;
	        }

	        var styleValue = unreadPropStyle[key];
	        if (typeof styleValue === 'number') {
	          if (!dirty) {
	            dirty = true;
	            someDirty = true;
	            currentStyles[i] = _extends({}, currentStyles[i]);
	            currentVelocities[i] = _extends({}, currentVelocities[i]);
	            lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
	            lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
	          }
	          currentStyles[i][key] = styleValue;
	          currentVelocities[i][key] = 0;
	          lastIdealStyles[i][key] = styleValue;
	          lastIdealVelocities[i][key] = 0;
	        }
	      }
	    }

	    if (someDirty) {
	      this.setState({ currentStyles: currentStyles, currentVelocities: currentVelocities, lastIdealStyles: lastIdealStyles, lastIdealVelocities: lastIdealVelocities });
	    }
	  },

	  startAnimationIfNecessary: function startAnimationIfNecessary() {
	    var _this = this;

	    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
	    // call cb? No, otherwise accidental parent rerender causes cb trigger
	    this.animationID = _raf2['default'](function (timestamp) {
	      var destStyles = _this.props.styles(_this.state.lastIdealStyles);

	      // check if we need to animate in the first place
	      if (shouldStopAnimationAll(_this.state.currentStyles, destStyles, _this.state.currentVelocities)) {
	        // no need to cancel animationID here; shouldn't have any in flight
	        _this.animationID = null;
	        _this.accumulatedTime = 0;
	        return;
	      }

	      var currentTime = timestamp || _performanceNow2['default']();
	      var timeDelta = currentTime - _this.prevTime;
	      _this.prevTime = currentTime;
	      _this.accumulatedTime = _this.accumulatedTime + timeDelta;
	      // more than 10 frames? prolly switched browser tab. Restart
	      if (_this.accumulatedTime > msPerFrame * 10) {
	        _this.accumulatedTime = 0;
	      }

	      if (_this.accumulatedTime === 0) {
	        // no need to cancel animationID here; shouldn't have any in flight
	        _this.animationID = null;
	        _this.startAnimationIfNecessary();
	        return;
	      }

	      var currentFrameCompletion = (_this.accumulatedTime - Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;
	      var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);

	      var newLastIdealStyles = [];
	      var newLastIdealVelocities = [];
	      var newCurrentStyles = [];
	      var newCurrentVelocities = [];

	      for (var i = 0; i < destStyles.length; i++) {
	        var destStyle = destStyles[i];
	        var newCurrentStyle = {};
	        var newCurrentVelocity = {};
	        var newLastIdealStyle = {};
	        var newLastIdealVelocity = {};

	        for (var key in destStyle) {
	          if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
	            continue;
	          }

	          var styleValue = destStyle[key];
	          if (typeof styleValue === 'number') {
	            newCurrentStyle[key] = styleValue;
	            newCurrentVelocity[key] = 0;
	            newLastIdealStyle[key] = styleValue;
	            newLastIdealVelocity[key] = 0;
	          } else {
	            var newLastIdealStyleValue = _this.state.lastIdealStyles[i][key];
	            var newLastIdealVelocityValue = _this.state.lastIdealVelocities[i][key];
	            for (var j = 0; j < framesToCatchUp; j++) {
	              var _stepper = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

	              newLastIdealStyleValue = _stepper[0];
	              newLastIdealVelocityValue = _stepper[1];
	            }

	            var _stepper2 = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

	            var nextIdealX = _stepper2[0];
	            var nextIdealV = _stepper2[1];

	            newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;
	            newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;
	            newLastIdealStyle[key] = newLastIdealStyleValue;
	            newLastIdealVelocity[key] = newLastIdealVelocityValue;
	          }
	        }

	        newCurrentStyles[i] = newCurrentStyle;
	        newCurrentVelocities[i] = newCurrentVelocity;
	        newLastIdealStyles[i] = newLastIdealStyle;
	        newLastIdealVelocities[i] = newLastIdealVelocity;
	      }

	      _this.animationID = null;
	      // the amount we're looped over above
	      _this.accumulatedTime -= framesToCatchUp * msPerFrame;

	      _this.setState({
	        currentStyles: newCurrentStyles,
	        currentVelocities: newCurrentVelocities,
	        lastIdealStyles: newLastIdealStyles,
	        lastIdealVelocities: newLastIdealVelocities
	      });

	      _this.unreadPropStyles = null;

	      _this.startAnimationIfNecessary();
	    });
	  },

	  componentDidMount: function componentDidMount() {
	    this.prevTime = _performanceNow2['default']();
	    this.startAnimationIfNecessary();
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(props) {
	    if (this.unreadPropStyles != null) {
	      // previous props haven't had the chance to be set yet; set them here
	      this.clearUnreadPropStyle(this.unreadPropStyles);
	    }

	    this.unreadPropStyles = props.styles(this.state.lastIdealStyles);
	    if (this.animationID == null) {
	      this.prevTime = _performanceNow2['default']();
	      this.startAnimationIfNecessary();
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    if (this.animationID != null) {
	      _raf2['default'].cancel(this.animationID);
	      this.animationID = null;
	    }
	  },

	  render: function render() {
	    var renderedChildren = this.props.children(this.state.currentStyles);
	    return renderedChildren && _react2['default'].Children.only(renderedChildren);
	  }
	});

	exports['default'] = StaggeredMotion;
	module.exports = exports['default'];

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mapToZero = __webpack_require__(6);

	var _mapToZero2 = _interopRequireDefault(_mapToZero);

	var _stripStyle = __webpack_require__(9);

	var _stripStyle2 = _interopRequireDefault(_stripStyle);

	var _stepper3 = __webpack_require__(8);

	var _stepper4 = _interopRequireDefault(_stepper3);

	var _mergeDiff = __webpack_require__(24);

	var _mergeDiff2 = _interopRequireDefault(_mergeDiff);

	var _performanceNow = __webpack_require__(3);

	var _performanceNow2 = _interopRequireDefault(_performanceNow);

	var _raf = __webpack_require__(5);

	var _raf2 = _interopRequireDefault(_raf);

	var _shouldStopAnimation = __webpack_require__(7);

	var _shouldStopAnimation2 = _interopRequireDefault(_shouldStopAnimation);

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var msPerFrame = 1000 / 60;

	// the children function & (potential) styles function asks as param an
	// Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format
	// {key: string, data?: any, style: PlainStyle}. However, the way we keep
	// internal states doesn't contain such a data structure (check the state and
	// TransitionMotionState). So when children function and others ask for such
	// data we need to generate them on the fly by combining mergedPropsStyles and
	// currentStyles/lastIdealStyles
	function rehydrateStyles(mergedPropsStyles, unreadPropStyles, plainStyles) {
	  // Copy the value to a `const` so that Flow understands that the const won't
	  // change and will be non-nullable in the callback below.
	  var cUnreadPropStyles = unreadPropStyles;
	  if (cUnreadPropStyles == null) {
	    return mergedPropsStyles.map(function (mergedPropsStyle, i) {
	      return {
	        key: mergedPropsStyle.key,
	        data: mergedPropsStyle.data,
	        style: plainStyles[i]
	      };
	    });
	  }
	  return mergedPropsStyles.map(function (mergedPropsStyle, i) {
	    for (var j = 0; j < cUnreadPropStyles.length; j++) {
	      if (cUnreadPropStyles[j].key === mergedPropsStyle.key) {
	        return {
	          key: cUnreadPropStyles[j].key,
	          data: cUnreadPropStyles[j].data,
	          style: plainStyles[i]
	        };
	      }
	    }
	    return { key: mergedPropsStyle.key, data: mergedPropsStyle.data, style: plainStyles[i] };
	  });
	}

	function shouldStopAnimationAll(currentStyles, destStyles, currentVelocities, mergedPropsStyles) {
	  if (mergedPropsStyles.length !== destStyles.length) {
	    return false;
	  }

	  for (var i = 0; i < mergedPropsStyles.length; i++) {
	    if (mergedPropsStyles[i].key !== destStyles[i].key) {
	      return false;
	    }
	  }

	  // we have the invariant that mergedPropsStyles and
	  // currentStyles/currentVelocities/last* are synced in terms of cells, see
	  // mergeAndSync comment for more info
	  for (var i = 0; i < mergedPropsStyles.length; i++) {
	    if (!_shouldStopAnimation2['default'](currentStyles[i], destStyles[i].style, currentVelocities[i])) {
	      return false;
	    }
	  }

	  return true;
	}

	// core key merging logic

	// things to do: say previously merged style is {a, b}, dest style (prop) is {b,
	// c}, previous current (interpolating) style is {a, b}
	// **invariant**: current[i] corresponds to merged[i] in terms of key

	// steps:
	// turn merged style into {a?, b, c}
	//    add c, value of c is destStyles.c
	//    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}
	// turn current (interpolating) style from {a, b} into {a?, b, c}
	//    maybe remove a
	//    certainly add c, value of c is willEnter(c)
	// loop over merged and construct new current
	// dest doesn't change, that's owner's
	function mergeAndSync(willEnter, willLeave, didLeave, oldMergedPropsStyles, destStyles, oldCurrentStyles, oldCurrentVelocities, oldLastIdealStyles, oldLastIdealVelocities) {
	  var newMergedPropsStyles = _mergeDiff2['default'](oldMergedPropsStyles, destStyles, function (oldIndex, oldMergedPropsStyle) {
	    var leavingStyle = willLeave(oldMergedPropsStyle);
	    if (leavingStyle == null) {
	      didLeave({ key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data });
	      return null;
	    }
	    if (_shouldStopAnimation2['default'](oldCurrentStyles[oldIndex], leavingStyle, oldCurrentVelocities[oldIndex])) {
	      didLeave({ key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data });
	      return null;
	    }
	    return { key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data, style: leavingStyle };
	  });

	  var newCurrentStyles = [];
	  var newCurrentVelocities = [];
	  var newLastIdealStyles = [];
	  var newLastIdealVelocities = [];
	  for (var i = 0; i < newMergedPropsStyles.length; i++) {
	    var newMergedPropsStyleCell = newMergedPropsStyles[i];
	    var foundOldIndex = null;
	    for (var j = 0; j < oldMergedPropsStyles.length; j++) {
	      if (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {
	        foundOldIndex = j;
	        break;
	      }
	    }
	    // TODO: key search code
	    if (foundOldIndex == null) {
	      var plainStyle = willEnter(newMergedPropsStyleCell);
	      newCurrentStyles[i] = plainStyle;
	      newLastIdealStyles[i] = plainStyle;

	      var velocity = _mapToZero2['default'](newMergedPropsStyleCell.style);
	      newCurrentVelocities[i] = velocity;
	      newLastIdealVelocities[i] = velocity;
	    } else {
	      newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];
	      newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];
	      newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];
	      newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];
	    }
	  }

	  return [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities];
	}

	var TransitionMotion = _react2['default'].createClass({
	  displayName: 'TransitionMotion',

	  propTypes: {
	    defaultStyles: _react.PropTypes.arrayOf(_react.PropTypes.shape({
	      key: _react.PropTypes.string.isRequired,
	      data: _react.PropTypes.any,
	      style: _react.PropTypes.objectOf(_react.PropTypes.number).isRequired
	    })),
	    styles: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.arrayOf(_react.PropTypes.shape({
	      key: _react.PropTypes.string.isRequired,
	      data: _react.PropTypes.any,
	      style: _react.PropTypes.objectOf(_react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.object])).isRequired
	    }))]).isRequired,
	    children: _react.PropTypes.func.isRequired,
	    willEnter: _react.PropTypes.func,
	    willLeave: _react.PropTypes.func,
	    didLeave: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      willEnter: function willEnter(styleThatEntered) {
	        return _stripStyle2['default'](styleThatEntered.style);
	      },
	      // recall: returning null makes the current unmounting TransitionStyle
	      // disappear immediately
	      willLeave: function willLeave() {
	        return null;
	      },
	      didLeave: function didLeave() {}
	    };
	  },

	  getInitialState: function getInitialState() {
	    var _props = this.props;
	    var defaultStyles = _props.defaultStyles;
	    var styles = _props.styles;
	    var willEnter = _props.willEnter;
	    var willLeave = _props.willLeave;
	    var didLeave = _props.didLeave;

	    var destStyles = typeof styles === 'function' ? styles(defaultStyles) : styles;

	    // this is special. for the first time around, we don't have a comparison
	    // between last (no last) and current merged props. we'll compute last so:
	    // say default is {a, b} and styles (dest style) is {b, c}, we'll
	    // fabricate last as {a, b}
	    var oldMergedPropsStyles = undefined;
	    if (defaultStyles == null) {
	      oldMergedPropsStyles = destStyles;
	    } else {
	      oldMergedPropsStyles = defaultStyles.map(function (defaultStyleCell) {
	        // TODO: key search code
	        for (var i = 0; i < destStyles.length; i++) {
	          if (destStyles[i].key === defaultStyleCell.key) {
	            return destStyles[i];
	          }
	        }
	        return defaultStyleCell;
	      });
	    }
	    var oldCurrentStyles = defaultStyles == null ? destStyles.map(function (s) {
	      return _stripStyle2['default'](s.style);
	    }) : defaultStyles.map(function (s) {
	      return _stripStyle2['default'](s.style);
	    });
	    var oldCurrentVelocities = defaultStyles == null ? destStyles.map(function (s) {
	      return _mapToZero2['default'](s.style);
	    }) : defaultStyles.map(function (s) {
	      return _mapToZero2['default'](s.style);
	    });

	    var _mergeAndSync = mergeAndSync(
	    // Because this is an old-style React.createClass component, Flow doesn't
	    // understand that the willEnter and willLeave props have default values
	    // and will always be present.
	    willEnter, willLeave, didLeave, oldMergedPropsStyles, destStyles, oldCurrentStyles, oldCurrentVelocities, oldCurrentStyles, // oldLastIdealStyles really
	    oldCurrentVelocities);

	    var mergedPropsStyles = _mergeAndSync[0];
	    var currentStyles = _mergeAndSync[1];
	    var currentVelocities = _mergeAndSync[2];
	    var lastIdealStyles = _mergeAndSync[3];
	    var lastIdealVelocities = _mergeAndSync[4];
	    // oldLastIdealVelocities really

	    return {
	      currentStyles: currentStyles,
	      currentVelocities: currentVelocities,
	      lastIdealStyles: lastIdealStyles,
	      lastIdealVelocities: lastIdealVelocities,
	      mergedPropsStyles: mergedPropsStyles
	    };
	  },

	  unmounting: false,
	  animationID: null,
	  prevTime: 0,
	  accumulatedTime: 0,
	  // it's possible that currentStyle's value is stale: if props is immediately
	  // changed from 0 to 400 to spring(0) again, the async currentStyle is still
	  // at 0 (didn't have time to tick and interpolate even once). If we naively
	  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
	  // In reality currentStyle should be 400
	  unreadPropStyles: null,
	  // after checking for unreadPropStyles != null, we manually go set the
	  // non-interpolating values (those that are a number, without a spring
	  // config)
	  clearUnreadPropStyle: function clearUnreadPropStyle(unreadPropStyles) {
	    var _mergeAndSync2 = mergeAndSync(this.props.willEnter, this.props.willLeave, this.props.didLeave, this.state.mergedPropsStyles, unreadPropStyles, this.state.currentStyles, this.state.currentVelocities, this.state.lastIdealStyles, this.state.lastIdealVelocities);

	    var mergedPropsStyles = _mergeAndSync2[0];
	    var currentStyles = _mergeAndSync2[1];
	    var currentVelocities = _mergeAndSync2[2];
	    var lastIdealStyles = _mergeAndSync2[3];
	    var lastIdealVelocities = _mergeAndSync2[4];

	    for (var i = 0; i < unreadPropStyles.length; i++) {
	      var unreadPropStyle = unreadPropStyles[i].style;
	      var dirty = false;

	      for (var key in unreadPropStyle) {
	        if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
	          continue;
	        }

	        var styleValue = unreadPropStyle[key];
	        if (typeof styleValue === 'number') {
	          if (!dirty) {
	            dirty = true;
	            currentStyles[i] = _extends({}, currentStyles[i]);
	            currentVelocities[i] = _extends({}, currentVelocities[i]);
	            lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
	            lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
	            mergedPropsStyles[i] = {
	              key: mergedPropsStyles[i].key,
	              data: mergedPropsStyles[i].data,
	              style: _extends({}, mergedPropsStyles[i].style)
	            };
	          }
	          currentStyles[i][key] = styleValue;
	          currentVelocities[i][key] = 0;
	          lastIdealStyles[i][key] = styleValue;
	          lastIdealVelocities[i][key] = 0;
	          mergedPropsStyles[i].style[key] = styleValue;
	        }
	      }
	    }

	    // unlike the other 2 components, we can't detect staleness and optionally
	    // opt out of setState here. each style object's data might contain new
	    // stuff we're not/cannot compare
	    this.setState({
	      currentStyles: currentStyles,
	      currentVelocities: currentVelocities,
	      mergedPropsStyles: mergedPropsStyles,
	      lastIdealStyles: lastIdealStyles,
	      lastIdealVelocities: lastIdealVelocities
	    });
	  },

	  startAnimationIfNecessary: function startAnimationIfNecessary() {
	    var _this = this;

	    if (this.unmounting) {
	      return;
	    }
	    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
	    // call cb? No, otherwise accidental parent rerender causes cb trigger
	    this.animationID = _raf2['default'](function (timestamp) {
	      var propStyles = _this.props.styles;
	      var destStyles = typeof propStyles === 'function' ? propStyles(rehydrateStyles(_this.state.mergedPropsStyles, _this.unreadPropStyles, _this.state.lastIdealStyles)) : propStyles;

	      // check if we need to animate in the first place
	      if (shouldStopAnimationAll(_this.state.currentStyles, destStyles, _this.state.currentVelocities, _this.state.mergedPropsStyles)) {
	        // no need to cancel animationID here; shouldn't have any in flight
	        _this.animationID = null;
	        _this.accumulatedTime = 0;
	        return;
	      }

	      var currentTime = timestamp || _performanceNow2['default']();
	      var timeDelta = currentTime - _this.prevTime;
	      _this.prevTime = currentTime;
	      _this.accumulatedTime = _this.accumulatedTime + timeDelta;
	      // more than 10 frames? prolly switched browser tab. Restart
	      if (_this.accumulatedTime > msPerFrame * 10) {
	        _this.accumulatedTime = 0;
	      }

	      if (_this.accumulatedTime === 0) {
	        // no need to cancel animationID here; shouldn't have any in flight
	        _this.animationID = null;
	        _this.startAnimationIfNecessary();
	        return;
	      }

	      var currentFrameCompletion = (_this.accumulatedTime - Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;
	      var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);

	      var _mergeAndSync3 = mergeAndSync(_this.props.willEnter, _this.props.willLeave, _this.props.didLeave, _this.state.mergedPropsStyles, destStyles, _this.state.currentStyles, _this.state.currentVelocities, _this.state.lastIdealStyles, _this.state.lastIdealVelocities);

	      var newMergedPropsStyles = _mergeAndSync3[0];
	      var newCurrentStyles = _mergeAndSync3[1];
	      var newCurrentVelocities = _mergeAndSync3[2];
	      var newLastIdealStyles = _mergeAndSync3[3];
	      var newLastIdealVelocities = _mergeAndSync3[4];

	      for (var i = 0; i < newMergedPropsStyles.length; i++) {
	        var newMergedPropsStyle = newMergedPropsStyles[i].style;
	        var newCurrentStyle = {};
	        var newCurrentVelocity = {};
	        var newLastIdealStyle = {};
	        var newLastIdealVelocity = {};

	        for (var key in newMergedPropsStyle) {
	          if (!Object.prototype.hasOwnProperty.call(newMergedPropsStyle, key)) {
	            continue;
	          }

	          var styleValue = newMergedPropsStyle[key];
	          if (typeof styleValue === 'number') {
	            newCurrentStyle[key] = styleValue;
	            newCurrentVelocity[key] = 0;
	            newLastIdealStyle[key] = styleValue;
	            newLastIdealVelocity[key] = 0;
	          } else {
	            var newLastIdealStyleValue = newLastIdealStyles[i][key];
	            var newLastIdealVelocityValue = newLastIdealVelocities[i][key];
	            for (var j = 0; j < framesToCatchUp; j++) {
	              var _stepper = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

	              newLastIdealStyleValue = _stepper[0];
	              newLastIdealVelocityValue = _stepper[1];
	            }

	            var _stepper2 = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

	            var nextIdealX = _stepper2[0];
	            var nextIdealV = _stepper2[1];

	            newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;
	            newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;
	            newLastIdealStyle[key] = newLastIdealStyleValue;
	            newLastIdealVelocity[key] = newLastIdealVelocityValue;
	          }
	        }

	        newLastIdealStyles[i] = newLastIdealStyle;
	        newLastIdealVelocities[i] = newLastIdealVelocity;
	        newCurrentStyles[i] = newCurrentStyle;
	        newCurrentVelocities[i] = newCurrentVelocity;
	      }

	      _this.animationID = null;
	      // the amount we're looped over above
	      _this.accumulatedTime -= framesToCatchUp * msPerFrame;

	      _this.setState({
	        currentStyles: newCurrentStyles,
	        currentVelocities: newCurrentVelocities,
	        lastIdealStyles: newLastIdealStyles,
	        lastIdealVelocities: newLastIdealVelocities,
	        mergedPropsStyles: newMergedPropsStyles
	      });

	      _this.unreadPropStyles = null;

	      _this.startAnimationIfNecessary();
	    });
	  },

	  componentDidMount: function componentDidMount() {
	    this.prevTime = _performanceNow2['default']();
	    this.startAnimationIfNecessary();
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(props) {
	    if (this.unreadPropStyles) {
	      // previous props haven't had the chance to be set yet; set them here
	      this.clearUnreadPropStyle(this.unreadPropStyles);
	    }

	    var styles = props.styles;
	    if (typeof styles === 'function') {
	      this.unreadPropStyles = styles(rehydrateStyles(this.state.mergedPropsStyles, this.unreadPropStyles, this.state.lastIdealStyles));
	    } else {
	      this.unreadPropStyles = styles;
	    }

	    if (this.animationID == null) {
	      this.prevTime = _performanceNow2['default']();
	      this.startAnimationIfNecessary();
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.unmounting = true;
	    if (this.animationID != null) {
	      _raf2['default'].cancel(this.animationID);
	      this.animationID = null;
	    }
	  },

	  render: function render() {
	    var hydratedStyles = rehydrateStyles(this.state.mergedPropsStyles, this.unreadPropStyles, this.state.currentStyles);
	    var renderedChildren = this.props.children(hydratedStyles);
	    return renderedChildren && _react2['default'].Children.only(renderedChildren);
	  }
	});

	exports['default'] = TransitionMotion;
	module.exports = exports['default'];

	// list of styles, each containing interpolating values. Part of what's passed
	// to children function. Notice that this is
	// Array<ActualInterpolatingStyleObject>, without the wrapper that is {key: ...,
	// data: ... style: ActualInterpolatingStyleObject}. Only mergedPropsStyles
	// contains the key & data info (so that we only have a single source of truth
	// for these, and to save space). Check the comment for `rehydrateStyles` to
	// see how we regenerate the entirety of what's passed to children function

	// the array that keeps track of currently rendered stuff! Including stuff
	// that you've unmounted but that's still animating. This is where it lives

/***/ },
/* 24 */
/***/ function(module, exports) {

	

	// core keys merging algorithm. If previous render's keys are [a, b], and the
	// next render's [c, b, d], what's the final merged keys and ordering?

	// - c and a must both be before b
	// - b before d
	// - ordering between a and c ambiguous

	// this reduces to merging two partially ordered lists (e.g. lists where not
	// every item has a definite ordering, like comparing a and c above). For the
	// ambiguous ordering we deterministically choose to place the next render's
	// item after the previous'; so c after a

	// this is called a topological sorting. Except the existing algorithms don't
	// work well with js bc of the amount of allocation, and isn't optimized for our
	// current use-case bc the runtime is linear in terms of edges (see wiki for
	// meaning), which is huge when two lists have many common elements
	'use strict';

	exports.__esModule = true;
	exports['default'] = mergeDiff;

	function mergeDiff(prev, next, onRemove) {
	  // bookkeeping for easier access of a key's index below. This is 2 allocations +
	  // potentially triggering chrome hash map mode for objs (so it might be faster

	  var prevKeyIndex = {};
	  for (var i = 0; i < prev.length; i++) {
	    prevKeyIndex[prev[i].key] = i;
	  }
	  var nextKeyIndex = {};
	  for (var i = 0; i < next.length; i++) {
	    nextKeyIndex[next[i].key] = i;
	  }

	  // first, an overly elaborate way of merging prev and next, eliminating
	  // duplicates (in terms of keys). If there's dupe, keep the item in next).
	  // This way of writing it saves allocations
	  var ret = [];
	  for (var i = 0; i < next.length; i++) {
	    ret[i] = next[i];
	  }
	  for (var i = 0; i < prev.length; i++) {
	    if (!Object.prototype.hasOwnProperty.call(nextKeyIndex, prev[i].key)) {
	      // this is called my TM's `mergeAndSync`, which calls willLeave. We don't
	      // merge in keys that the user desires to kill
	      var fill = onRemove(i, prev[i]);
	      if (fill != null) {
	        ret.push(fill);
	      }
	    }
	  }

	  // now all the items all present. Core sorting logic to have the right order
	  return ret.sort(function (a, b) {
	    var nextOrderA = nextKeyIndex[a.key];
	    var nextOrderB = nextKeyIndex[b.key];
	    var prevOrderA = prevKeyIndex[a.key];
	    var prevOrderB = prevKeyIndex[b.key];

	    if (nextOrderA != null && nextOrderB != null) {
	      // both keys in next
	      return nextKeyIndex[a.key] - nextKeyIndex[b.key];
	    } else if (prevOrderA != null && prevOrderB != null) {
	      // both keys in prev
	      return prevKeyIndex[a.key] - prevKeyIndex[b.key];
	    } else if (nextOrderA != null) {
	      // key a in next, key b in prev

	      // how to determine the order between a and b? We find a "pivot" (term
	      // abuse), a key present in both prev and next, that is sandwiched between
	      // a and b. In the context of our above example, if we're comparing a and
	      // d, b's (the only) pivot
	      for (var i = 0; i < next.length; i++) {
	        var pivot = next[i].key;
	        if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {
	          continue;
	        }

	        if (nextOrderA < nextKeyIndex[pivot] && prevOrderB > prevKeyIndex[pivot]) {
	          return -1;
	        } else if (nextOrderA > nextKeyIndex[pivot] && prevOrderB < prevKeyIndex[pivot]) {
	          return 1;
	        }
	      }
	      // pluggable. default to: next bigger than prev
	      return 1;
	    }
	    // prevOrderA, nextOrderB
	    for (var i = 0; i < next.length; i++) {
	      var pivot = next[i].key;
	      if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {
	        continue;
	      }
	      if (nextOrderB < nextKeyIndex[pivot] && prevOrderA > prevKeyIndex[pivot]) {
	        return 1;
	      } else if (nextOrderB > nextKeyIndex[pivot] && prevOrderA < prevKeyIndex[pivot]) {
	        return -1;
	      }
	    }
	    // pluggable. default to: next bigger than prev
	    return -1;
	  });
	}

	module.exports = exports['default'];
	// to loop through and find a key's index each time), but I no longer care

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = reorderKeys;

	var hasWarned = false;

	function reorderKeys() {
	  if (false) {
	    if (!hasWarned) {
	      hasWarned = true;
	      console.error('`reorderKeys` has been removed, since it is no longer needed for TransitionMotion\'s new styles array API.');
	    }
	  }
	}

	module.exports = exports['default'];

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = spring;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _presets = __webpack_require__(10);

	var _presets2 = _interopRequireDefault(_presets);

	var defaultConfig = _extends({}, _presets2['default'].noWobble, {
	  precision: 0.01
	});

	function spring(val, config) {
	  return _extends({}, defaultConfig, config, { val: val });
	}

	module.exports = exports['default'];

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable no-undefined */

	var throttle = __webpack_require__(13);

	/**
	 * Debounce execution of a function. Debouncing, unlike throttling,
	 * guarantees that a function is only executed a single time, either at the
	 * very beginning of a series of calls, or at the very end.
	 *
	 * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
	 * @param  {Boolean}  atBegin       Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
	 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
	 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
	 * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
	 *                                  to `callback` when the debounced-function is executed.
	 *
	 * @return {Function} A new, debounced function.
	 */
	module.exports = function ( delay, atBegin, callback ) {
		return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
	};


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var throttle = __webpack_require__(13);
	var debounce = __webpack_require__(27);

	module.exports = {
		throttle: throttle,
		debounce: debounce
	};


/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_29__;

/***/ }
/******/ ])
});
;